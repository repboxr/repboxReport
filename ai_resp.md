Of course. I will update the report generation logic to meet your new requirements for the cell tooltips. The tooltips will now be dynamic, reflecting the currently active map version, and a more intelligent conflict-detection mechanism will be implemented in R to avoid unnecessary warnings.

Here is the plan:

1.  **Update `rr_map_report` (`R/report_map.R`):** I will modify this function to pre-compute a "conflict map" in R. This map will identify cells that are linked to different script files or code lines across various map versions and generate a detailed warning message for their tooltips. This data will be passed to the JavaScript environment of the report.

2.  **Update `rr_process_single_map_for_js` (`R/report_map.R`):** This helper function will be enhanced to create a `cell_map` for each individual map version. This map will contain all the necessary details (`runid`, `reg_ind`, `script_num`, `code_line`) for each cell, allowing the JavaScript to dynamically build the tooltips for the currently selected map.

3.  **Rewrite `report_map.js` (`inst/www/report_map.js`):** The JavaScript will be completely rewritten to handle the new data structures. It will now update all cell tooltips whenever the user selects a different map version, combining the dynamic information from the active map with the static conflict warnings pre-computed by R.

Here are the detailed modifications:

!MODIFICATION rr_map_report in R/report_map.R
scope = "function"
file = "R/report_map.R"
function_name = "rr_map_report"
description = '''Updates `rr_map_report` to generate and embed `cell_conflict_data`. This is a pre-computed map that contains warning messages for cells mapped inconsistently (different script/line) across different map versions. This avoids client-side computation.'''
---
```r
#' Creates an interactive HTML report to visualize maps
#'
#' This function generates a self-contained HTML report that visualizes the
#' maps between Stata do-files and regression tables. The report features
#' static color-coding for regression cells and interactive highlighting.
#'
#' @param project_dir The root directory of the project.
#' @param output_dir Directory for the report. Defaults to 'reports' in project_dir.
#' @param output_file The name of the HTML report file.
#' @param doc_type The document type (e.g., "art", "app1").
#' @param opts A list of options, typically generated by `rr_map_report_opts()`.
#' @return The path to the generated HTML report file.
#' @export
rr_map_report <- function(project_dir,
                          output_dir = file.path(project_dir, "reports"),
                          output_file = "map_report.html",
                          doc_type = "art",
                          opts = NULL) {
  restore.point("rr_map_report")
  # --- 0. Check dependencies & Options ---
  pkgs <- c("dplyr", "tidyr", "stringi", "htmltools", "jsonlite", "purrr", "randtoolbox")
  for (pkg in pkgs) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      stop(paste("Please install the '", pkg, "' package."), call. = FALSE)
    }
  }

  if (is.null(opts)) {
    opts <- rr_map_report_opts()
  }

  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  # --- 1. Setup asset paths ---
  assets_dir <- file.path(output_dir, "shared")
  if (!dir.exists(assets_dir)) {
    dir.create(assets_dir, recursive = TRUE)
  }

  # --- 2. Load data ---
  message("Loading data...")
  parcels <- repboxDB::repdb_load_parcels(project_dir, c("stata_source", "stata_run_cmd", "stata_run_log", "stata_cmd"))

  fp_dir <- file.path(project_dir, "fp", paste0("prod_", doc_type))
  tab_main_info <- rai_pick_tab_ver(fp_dir, "tab_main")
  if(nrow(tab_main_info) == 0) {
      stop("Could not find a suitable 'tab_main' product for doc_type '", doc_type, "'")
  }
  tab_main <- fp_load_prod_df(tab_main_info$ver_dir)

  message("Loading maps...")
  all_map_types <- list()
  prod_id = "map_reg_run"
  for (prod_id in opts$map_prod_ids) {
    map_list <- rr_load_all_map_versions(project_dir, doc_type, prod_id = prod_id)
    if (length(map_list) > 0) {
      all_map_types[[prod_id]] <- map_list
    }
  }
  if (length(all_map_types) == 0) {
    warning("No map versions found for any prod_id in opts$map_prod_ids. The report will be generated without interactive links.")
  }

  # Standardize reg_ind across all map types
  if (length(all_map_types) > 0) {
      message("Standardizing regression indices...")
      # source("R/standardize_reg_ind.R") # This line would be used to load the function
      all_map_types <- rr_standardize_reg_ind(all_map_types)
  }


  # --- 3. Generate HTML & JS components ---
  message("Generating HTML components...")

  # Pre-compute conflict information for tooltips.
  # A conflict exists if a cell_id maps to different script/line combinations
  # across different map versions.
  cell_conflict_data <- {
    all_maps_flat <- unlist(all_map_types, recursive = FALSE)
    if (length(all_maps_flat) > 1) { # Conflicts only possible with more than 1 map version
        all_maps_flat_df <- purrr::map_dfr(all_maps_flat, ~.x, .id = "map_version_id")

        conflict_df <- all_maps_flat_df %>%
          rr_robust_script_num_join(parcels$stata_source$script_source) %>%
          dplyr::filter(!is.na(.data$cell_ids), .data$cell_ids != "", !is.na(.data$script_num), !is.na(.data$code_line)) %>%
          dplyr::select(.data$map_version_id, .data$script_num, .data$code_line, .data$cell_ids) %>%
          dplyr::mutate(cell_id = strsplit(as.character(.data$cell_ids), ",")) %>%
          tidyr::unnest(.data$cell_id) %>%
          dplyr::mutate(cell_id = trimws(.data$cell_id)) %>%
          dplyr::filter(.data$cell_id != "") %>%
          dplyr::select(.data$map_version_id, .data$cell_id, .data$script_num, .data$code_line) %>%
          dplyr::distinct()

        conflict_summary <- conflict_df %>%
          dplyr::group_by(.data$cell_id) %>%
          dplyr::mutate(target_key = paste(.data$script_num, .data$code_line, sep = ":")) %>%
          dplyr::summarise(
            num_unique_targets = dplyr::n_distinct(.data$target_key),
            conflict_info = if (dplyr::n_distinct(.data$target_key) > 1) {
              list(dplyr::tibble(map_version_id = .data$map_version_id, script_num = .data$script_num, code_line = .data$code_line))
            } else {
              list(NULL)
            }
          ) %>%
          dplyr::filter(.data$num_unique_targets > 1)

        if (nrow(conflict_summary) > 0) {
          setNames(
            lapply(conflict_summary$conflict_info, function(info_df) {
              details <- info_df %>%
                dplyr::distinct(.data$map_version_id, .data$script_num, .data$code_line) %>%
                dplyr::mutate(msg = paste0(.data$map_version_id, " -> S", .data$script_num, " L", .data$code_line)) %>%
                dplyr::pull(.data$msg)
              paste0("Note: Mapped differently in other versions:\n - ", paste(details, collapse="\n - "))
            }),
            conflict_summary$cell_id
          )
        } else {
          list()
        }
    } else {
      list()
    }
  }
  js_conflict_data <- jsonlite::toJSON(cell_conflict_data, auto_unbox = TRUE)


  # Generate color map for consistent colors across all loaded maps
  all_map_dfs <- unlist(all_map_types, recursive = FALSE)
  all_reg_inds <- unique(unlist(lapply(all_map_dfs, function(df) if("reg_ind" %in% names(df)) unique(df$reg_ind) else NULL)))
  all_reg_inds <- stats::na.omit(all_reg_inds)
  reg_color_map <- rr_make_distinct_colors(length(all_reg_inds))
  names(reg_color_map) <- all_reg_inds



  # Add a script_file column for easier access
  parcels$stata_source$script_source$script_file <- basename(parcels$stata_source$script_source$file_path)

  do_panel_html <- rr_make_do_panel_html(
    stata_source = parcels$stata_source$script_source,
    stata_cmd = parcels$stata_cmd$stata_cmd,
    stata_run_cmd = parcels$stata_run_cmd$stata_run_cmd,
    stata_run_log = parcels$stata_run_log$stata_run_log,
    opts = opts,
    all_map_types = all_map_types
  )

  tab_panel_html <- rr_make_tab_panel_html(tab_main)
  controls_html <- rr_make_controls_html(all_map_types)

  # --- 4. Write JS and CSS assets ---
  message("Writing JS and CSS assets...")
  rr_copy_pkg_assets(output_dir)

  # --- 5. Generate JS data and Assemble final HTML report ---

  # Conditionally generate map data (embedded vs. external)
  js_maps_data <- "{}"
  js_manifest_data <- "{}"

  if (isTRUE(opts$embed_data)) {
    message("Generating and embedding map data...")
    processed_types <- purrr::map(all_map_types, function(map_list_for_type) {
        purrr::map(map_list_for_type, function(map_df) {
            rr_process_single_map_for_js(map_df, reg_color_map, parcels$stata_source$script_source)
        })
    })
    js_maps_data <- jsonlite::toJSON(processed_types, auto_unbox = TRUE, null = "null", na = "null")
  } else {
    message("Generating external JSON files for map data...")
    maps_data_dir <- file.path(output_dir, "maps_data")
    if (!dir.exists(maps_data_dir)) dir.create(maps_data_dir, recursive = TRUE)

    manifest <- list()
    for (map_type in names(all_map_types)) {
        manifest[[map_type]] <- list()
        for (version_id in names(all_map_types[[map_type]])) {
            map_df <- all_map_types[[map_type]][[version_id]]
            processed_map_list <- rr_process_single_map_for_js(map_df, reg_color_map, parcels$stata_source$script_source)
            json_content <- jsonlite::toJSON(processed_map_list, auto_unbox = TRUE, null = "null", na = "null")

            file_name <- paste0(map_type, "_", version_id, ".json")
            file_path <- file.path(maps_data_dir, file_name)
            relative_path <- file.path("maps_data", file_name)

            writeLines(json_content, file_path)
            manifest[[map_type]][[version_id]] <- relative_path
        }
    }
    js_manifest_data <- jsonlite::toJSON(manifest, auto_unbox = TRUE)
    message("\nExternal JSONs generated. Note: This report must now be viewed via a web server.")
    message("You can start one from R with: servr::httd('", normalizePath(output_dir, mustWork=FALSE), "')")
  }


  message("Assembling final HTML report...")
  html_content <- htmltools::tagList(
    htmltools::tags$head(
      htmltools::tags$meta(charset = "UTF-8"),
      htmltools::tags$meta(`http-equiv` = "X-UA-Compatible", content = "IE=edge"),
      htmltools::tags$meta(name="viewport", content="width=device-width, initial-scale=1"),
      htmltools::tags$title(paste("map Report:", basename(project_dir))),
      htmltools::tags$link(href = "shared/bootstrap.min.css", rel = "stylesheet"),
      htmltools::tags$link(href = "shared/repbox.css", rel = "stylesheet")
    ),
    htmltools::tags$body(
      htmltools::tags$div(class = "container-fluid",
        htmltools::HTML(controls_html),
        htmltools::tags$div(class = "row", style = "height: 95vh;",
          htmltools::tags$div(id = "do-col-div", class = "col-sm-7",
            htmltools::HTML(do_panel_html)
          ),
          htmltools::tags$div(id = "tabs-col-div", class = "col-sm-5",
            htmltools::HTML(tab_panel_html)
          )
        )
      ),
      htmltools::tags$script(src = "shared/jquery.min.js"),
      htmltools::tags$script(src = "shared/bootstrap.min.js"),
      htmltools::tags$script(htmltools::HTML(paste0("var data_is_embedded = ", tolower(isTRUE(opts$embed_data)), ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var all_maps = ", js_maps_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var report_manifest = ", js_manifest_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var cell_conflict_data = ", js_conflict_data, ";"))),
      htmltools::tags$script(src = "shared/report_map.js")
    )
  )

  report_path <- file.path(output_dir, output_file)
  htmltools::save_html(html_content, file = report_path)

  message(paste("\nReport generated successfully at:", report_path))
  return(invisible(report_path))
}
```
!END_MODIFICATION rr_map_report in R/report_map.R

!MODIFICATION rr_process_single_map_for_js in report_map.R
scope = "function"
file = "R/report_map.R"
function_name = "rr_process_single_map_for_js"
description = '''Updates `rr_process_single_map_for_js` to generate a `cell_map` object. This new structure provides a direct mapping from a `cell_id` to its specific metadata (`runid`, `script_num`, `code_line`, `reg_ind`) for that map version, enabling dynamic tooltips in JavaScript.'''
---
```r
# Helper to process a single map data frame into a JS-ready list structure
rr_process_single_map_for_js <- function(map_df, reg_color_map, stata_source) {
    restore.point("rr_process_single_map_for_js")
    if (is.null(map_df) || nrow(map_df) == 0) {
      # Return the new empty structure
      return(list(code_locations = list(), cell_to_code_idx = list(),
                  code_to_cells = list(), reg_info = setNames(list(), character(0)),
                  wrong_number_info = list(), cell_map = list()))
    }

    # Robustly join to get script_num
    map_df <- rr_robust_script_num_join(map_df, stata_source)

    ensure_cols <- c("runid", "script_num", "code_line", "cell_ids", "tabid", "reg_ind")
    for (col in ensure_cols) {
      if (!col %in% names(map_df)) {
        map_df[[col]] <- if (col %in% c("runid", "script_num", "code_line", "reg_ind")) NA_integer_ else NA_character_
      }
    }

    # --- NEW LOGIC FOR COMPACT CELL->CODE MAPPING (for highlighting) ---
    cell_map_df_highlight <- map_df %>%
      dplyr::filter(!is.na(.data$cell_ids), .data$cell_ids != "", !is.na(.data$script_num), !is.na(.data$code_line)) %>%
      dplyr::mutate(cell_id = strsplit(as.character(.data$cell_ids), ",")) %>%
      tidyr::unnest(.data$cell_id) %>%
      dplyr::mutate(cell_id = trimws(.data$cell_id)) %>%
      dplyr::select(.data$cell_id, .data$runid, .data$script_num, .data$code_line)

    if (nrow(cell_map_df_highlight) > 0) {
        # 1. Find unique code locations and assign a 0-based index
        unique_locations <- cell_map_df_highlight %>%
          dplyr::select(.data$runid, .data$script_num, .data$code_line) %>%
          dplyr::distinct() %>%
          dplyr::arrange(.data$runid, .data$script_num, .data$code_line) %>%
          dplyr::mutate(location_idx = dplyr::row_number() - 1)

        # 2. Create the list of location arrays for JSON
        code_locations_list <- purrr::pmap(unique_locations[, c("runid", "script_num", "code_line")], c)

        # 3. Join back to get the index for each cell and create the named list
        cell_to_idx_df <- dplyr::left_join(cell_map_df_highlight, unique_locations, by = c("runid", "script_num", "code_line"))
        cell_to_code_idx <- setNames(as.list(cell_to_idx_df$location_idx), cell_to_idx_df$cell_id)
    } else {
        code_locations_list <- list()
        cell_to_code_idx <- list()
    }
    # --- END OF COMPACT LOGIC ---

    # --- NEW logic for cell_map for tooltips ---
    cell_map_df_tooltip <- map_df %>%
      dplyr::filter(!is.na(.data$cell_ids), .data$cell_ids != "", !is.na(.data$script_num)) %>%
      dplyr::select(.data$runid, .data$script_num, .data$code_line, .data$reg_ind, .data$cell_ids) %>%
      dplyr::mutate(cell_id = strsplit(as.character(.data$cell_ids), ",")) %>%
      tidyr::unnest(.data$cell_id) %>%
      dplyr::mutate(cell_id = trimws(.data$cell_id)) %>%
      dplyr::filter(.data$cell_id != "") %>%
      dplyr::group_by(.data$cell_id) %>%
      dplyr::summarise(
        runid = dplyr::first(.data$runid),
        script_num = dplyr::first(.data$script_num),
        code_line = dplyr::first(.data$code_line),
        reg_ind = dplyr::first(.data$reg_ind)
      )

    cell_map <- if (nrow(cell_map_df_tooltip) > 0) {
      purrr::transpose(cell_map_df_tooltip[, -1]) %>%
        setNames(cell_map_df_tooltip$cell_id)
    } else {
      list()
    }


    code_map_df <- map_df %>%
      dplyr::filter(!is.na(.data$code_line), !is.na(.data$script_num)) %>%
      dplyr::select(.data$script_num, .data$code_line, .data$tabid, .data$cell_ids) %>%
      dplyr::distinct()
    code_to_cells <- if (nrow(code_map_df) > 0) setNames(lapply(1:nrow(code_map_df), function(i) as.list(code_map_df[i, c("tabid", "cell_ids")])), paste0("s", code_map_df$script_num, "_l", code_map_df$code_line)) else list()
    reg_info <- setNames(list(), character(0))
    if ("reg_ind" %in% names(map_df) && length(reg_color_map) > 0) {
      reg_df <- map_df %>%
        dplyr::filter(!is.na(.data$reg_ind), !is.na(.data$cell_ids), .data$cell_ids != "") %>%
        dplyr::select(.data$reg_ind, .data$cell_ids) %>%
        dplyr::group_by(.data$reg_ind) %>%
        dplyr::summarise(all_cell_ids = paste(unique(trimws(unlist(strsplit(.data$cell_ids, ",")))), collapse = ","), .groups = "drop")
      if (nrow(reg_df) > 0) {
        reg_info_list <- lapply(1:nrow(reg_df), function(i) {
            reg_index_char <- as.character(reg_df$reg_ind[i])
            if (reg_index_char %in% names(reg_color_map)) list(color = reg_color_map[[reg_index_char]], cell_ids = reg_df$all_cell_ids[i]) else NULL
          })
        names(reg_info_list) <- reg_df$reg_ind
        reg_info <- reg_info_list[!sapply(reg_info_list, is.null)]
      }
    }

    # --- Process wrong number cases ---
    wrong_number_info <- list()
    if ("wrong_number_cases" %in% names(map_df) && "tabid" %in% names(map_df)) {
        # The list column from JSON can contain NULLs for empty arrays. Filter these out.
        wnc_df <- map_df %>%
            dplyr::select(.data$tabid, .data$wrong_number_cases) %>%
            dplyr::filter(!sapply(.data$wrong_number_cases, function(x) is.null(x) || NROW(x) == 0))

        if (nrow(wnc_df) > 0) {
            wrong_number_info <- wnc_df %>%
                tidyr::unnest(cols = .data$wrong_number_cases) %>%
                dplyr::select(
                    .data$tabid,
                    .data$cell_id,
                    .data$wrong_number_in_cell,
                    .data$number_in_stata_output
                ) %>%
                dplyr::distinct()
        }
    }


    # Return the new structure
    list(
      code_locations = code_locations_list,
      cell_to_code_idx = cell_to_code_idx,
      code_to_cells = code_to_cells,
      reg_info = reg_info,
      wrong_number_info = wrong_number_info,
      cell_map = cell_map
    )
}
```
!END_MODIFICATION rr_process_single_map_for_js in report_map.R

!MODIFICATION report_map.js
scope = "file"
file = "inst/www/report_map.js"
is_new_file = false
description = '''Rewrites `report_map.js` to implement dynamic cell tooltips. The script now updates all tooltips on map version change, using a combination of dynamic data from the active map (`cell_map`) and static, pre-computed conflict information (`cell_conflict_data`).'''
---
```javascript
// FILE: report_map.js

// Global variables set by the R backend
// var data_is_embedded = true;
// var all_maps = { ... }; // Populated if data_is_embedded is true
// var report_manifest = { ... }; // Populated if data_is_embedded is false
// var cell_conflict_data = { ... }; // Populated with pre-computed conflict info

var active_map_type = "";
var active_version = "";
var active_mapping = {};

var last_code_highlight = "";
var last_cell_highlights = [];

function clear_all_highlights() {
    if (last_code_highlight) {
        $(last_code_highlight).removeClass("code-highlight");
        last_code_highlight = "";
    }
    last_cell_highlights.forEach(function(id) {
        $(id).removeClass("cell-highlight");
    });
    last_cell_highlights = [];
    // Also clear highlights from discrepancy report clicks
    $(".wrong-number-report-highlight").removeClass("wrong-number-report-highlight");
}

function clear_static_coloring() {
    // We must iterate over each element to remove the specific style
    // property that was set with '!important'. Standard .css() won't work.
    $(".statically-colored").each(function() {
        this.style.removeProperty('background-color');
        $(this).removeClass("statically-colored");
    });
}

function apply_static_coloring(mapping) {
    clear_static_coloring();
    if (!mapping || !mapping.reg_info) return;

    const reg_info = mapping.reg_info;
    for (const reg_ind in reg_info) {
        if (reg_info.hasOwnProperty(reg_ind)) {
            const info = reg_info[reg_ind];
            if (info.color && info.cell_ids) {
                const cell_ids = info.cell_ids.split(',');
                cell_ids.forEach(id => {
                    const cell_selector = "#" + id.trim();
                    const element = $(cell_selector);

                    if (element.length > 0) {
                        // Use the DOM element's setProperty method to add '!important'.
                        // This ensures our coloring rule has the highest priority and will
                        // override any conflicting styles (like from Bootstrap or other CSS).
                        element[0].style.setProperty('background-color', info.color, 'important');
                        element.addClass('statically-colored');
                    }
                });
            }
        }
    }
}

function apply_wrong_number_info(mapping) {
    // Clear previous reports and styling
    $(".wrong-number-report").remove();
    $(".wrong-number-cell").each(function() {
        this.style.removeProperty('background-image');
        $(this).removeClass("wrong-number-cell");
    });

    if (!mapping || !mapping.wrong_number_info || !Array.isArray(mapping.wrong_number_info) || mapping.wrong_number_info.length === 0) {
        return;
    }

    // Build a map from cell ID to its regression color for this specific map version
    const cell_to_color = {};
    if (mapping.reg_info) {
        for (const reg_ind in mapping.reg_info) {
            const info = mapping.reg_info[reg_ind];
            if (info.color && info.cell_ids) {
                info.cell_ids.split(',').forEach(id => {
                    cell_to_color[id.trim()] = info.color;
                });
            }
        }
    }

    const wrong_cases_by_tab = {};
    mapping.wrong_number_info.forEach(case_item => {
        const tabid = String(case_item.tabid); // Ensure tabid is a string
        if (!wrong_cases_by_tab[tabid]) {
            wrong_cases_by_tab[tabid] = [];
        }
        wrong_cases_by_tab[tabid].push(case_item);

        // Apply styling to the cell
        const cell_element = $("#" + case_item.cell_id);
        if (cell_element.length > 0) {
            cell_element.addClass("wrong-number-cell");
            const reg_color = cell_to_color[case_item.cell_id] || '#f0f0f0'; // Default color if not found
            const gradient = `linear-gradient(45deg, #cccccc, ${reg_color})`;
            // This will be rendered on top of the background-color set by static coloring
            cell_element[0].style.setProperty('background-image', gradient, 'important');
        }
    });

    // Generate and append reports for each table that has wrong numbers
    for (const tabid in wrong_cases_by_tab) {
        if (wrong_cases_by_tab.hasOwnProperty(tabid)) {
            const cases_for_tab = wrong_cases_by_tab[tabid];
            let report_html = '<div class="wrong-number-report">';
            report_html += '<h6>Discrepancies Found (click to locate):</h6><ul>';
            cases_for_tab.forEach(case_item => {
                report_html += `<li class="wrong-number-report-item" data-cell-id="${case_item.cell_id}">Cell <code>${case_item.cell_id}</code>: Table shows ${case_item.wrong_number_in_cell}, but script output is ${case_item.number_in_stata_output}.</li>`;
            });
            report_html += '</ul></div>';

            // Find the correct table div to append to
            const table_container = $("#tabtab" + tabid + " .art-tab-div");
            if (table_container.length > 0) {
                table_container.append(report_html);
            }
        }
    }
}


function highlight_code(script_num, line_num) {
    $("#dotabs a[href='#dotab_" + script_num + "']").tab("show");

    // Defer actions to allow tab to show first
    setTimeout(function() {
        const code_id = "#L" + line_num + "___" + script_num;
        $(code_id).addClass("code-highlight");
        last_code_highlight = code_id;

        const targetElement = document.querySelector(code_id);
        if(targetElement) {
            targetElement.scrollIntoView({ behavior: "smooth", block: "center" });
        }
    }, 150);
}

function highlight_cells(tabid, cell_ids_string) {
    if (!tabid || !cell_ids_string) return;
    $("#tabtabs a[href='#tabtab" + tabid + "']").tab("show");

    setTimeout(function() {
        const cell_ids = cell_ids_string.split(",");
        cell_ids.forEach(id => {
            const cell_selector = "#" + id.trim();
            $(cell_selector).addClass("cell-highlight");
            last_cell_highlights.push(cell_selector);
        });
        if (cell_ids.length > 0) {
            const targetElement = document.querySelector("#" + cell_ids[0].trim());
            if(targetElement) {
               targetElement.scrollIntoView({ behavior: "smooth", block: "center" });
            }
        }
    }, 150);
}

// Function to update the version selector based on the active map type
function update_version_selector() {
    // The source of map keys depends on the data loading mode.
    const source = data_is_embedded ? all_maps : report_manifest;
    const versions = Object.keys(source[active_map_type] || {});
    const version_selector = $("#version_selector");
    version_selector.empty();
    versions.forEach(function(v) {
        version_selector.append($("<option></option>").attr("value", v).text(v));
    });
}

function update_all_cell_titles() {
    const cell_map = active_mapping ? active_mapping.cell_map : null;

    $("[id^=c][id*=_]").each(function() {
        const cell_id = this.id;
        let title_parts = [`cell_id: ${cell_id}`];

        // 1. Add info from the currently active map version
        if (cell_map && cell_map[cell_id]) {
            const info = cell_map[cell_id];
            if (info.reg_ind !== null) title_parts.push(`reg_ind: ${info.reg_ind}`);
            if (info.runid !== null) title_parts.push(`runid: ${info.runid}`);
            if (info.script_num !== null && info.code_line !== null) {
                title_parts.push(`script: ${info.script_num}, line: ${info.code_line}`);
            }
        }

        // 2. Add static conflict info if it exists
        if (typeof cell_conflict_data !== 'undefined' && cell_conflict_data[cell_id]) {
            title_parts.push(cell_conflict_data[cell_id]);
        }

        $(this).attr('title', title_parts.join('\n'));
    });
}

function handle_map_change() {
    clear_all_highlights();

    const apply_updates = (map_data) => {
        active_mapping = map_data || {};
        apply_static_coloring(active_mapping);
        apply_wrong_number_info(active_mapping);
        update_all_cell_titles();
    };

    if (data_is_embedded) {
        // EMBEDDED MODE: Simply look up the data in the global object
        const map_data = all_maps[active_map_type] ? all_maps[active_map_type][active_version] : null;
        apply_updates(map_data);
    } else {
        // EXTERNAL MODE: Fetch the data from the corresponding JSON file
        const file_path = report_manifest[active_map_type]?.[active_version];
        if (!file_path) {
            apply_updates(null);
            return;
        }

        const selectors = $("#map_type_selector, #version_selector");
        selectors.prop("disabled", true); // Disable controls during fetch

        fetch(file_path)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                apply_updates(data);
            })
            .catch(error => {
                console.error("Failed to fetch map data:", error);
                alert("Failed to load map data. Please ensure you are viewing this report via a web server and the file exists: " + file_path);
                apply_updates(null);
            })
            .finally(() => {
                selectors.prop("disabled", false); // Re-enable controls
            });
    }
}


$(document).ready(function() {
    const map_types = Object.keys(data_is_embedded ? all_maps : report_manifest);
    if (map_types.length === 0) {
        $(".controls-div").hide();
        return;
    }

    // --- 1. DEFINE EVENT HANDLERS FIRST ---

    // Change map type
    $("#map_type_selector").on("change", function() {
        active_map_type = $(this).val();
        update_version_selector();
        $("#version_selector").trigger("change"); // Trigger version change to update view
    });

    // Change map version
    $("#version_selector").on("change", function() {
        active_version = $(this).val();
        handle_map_change();
    });

    // Click on a table cell
    $(document).on("click", ".tabnum, [id^=c][id*=_]", function(event) {
        clear_all_highlights();
        const cell_id = event.currentTarget.id;

        if (active_mapping && active_mapping.cell_to_code_idx && active_mapping.code_locations) {
            const location_idx = active_mapping.cell_to_code_idx[cell_id];
            if (typeof location_idx !== 'undefined') {
                const location_data = active_mapping.code_locations[location_idx];
                $(event.currentTarget).addClass("cell-highlight");
                last_cell_highlights.push("#" + cell_id);
                const script_num = location_data[1];
                const code_line = location_data[2];
                highlight_code(script_num, code_line);
            }
        }
    });

    // Click on a regression command in a do-file
    $(document).on("click", ".reg-cmd", function(event) {
        clear_all_highlights();
        const code_el = $(event.currentTarget);
        const code_id_parts = code_el.attr("id").split("___");
        const line = code_id_parts[0].substring(1);
        const script_num = code_id_parts[1];
        const lookup_key = "s" + script_num + "_l" + line;

        if (active_mapping && active_mapping.code_to_cells && active_mapping.code_to_cells[lookup_key]) {
            const mapping = active_mapping.code_to_cells[lookup_key];
            code_el.addClass("code-highlight");
            last_code_highlight = "#" + code_el.attr("id");
            highlight_cells(mapping.tabid, mapping.cell_ids);
        }
    });

    // Click on an item in the discrepancy report
    $(document).on("click", ".wrong-number-report-item", function() {
        clear_all_highlights();
        const cell_id = $(this).data("cell-id");
        if (!cell_id) return;
        const cell_element = $("#" + cell_id);
        if (cell_element.length > 0) {
            const tab_pane = cell_element.closest('.tab-pane[id^=tabtab]');
            if (tab_pane.length > 0) {
                const tab_id = tab_pane.attr('id');
                $('#tabtabs a[href="#' + tab_id + '"]').tab('show');
            }
            setTimeout(function() {
                cell_element[0].scrollIntoView({ behavior: "smooth", block: "center" });
                cell_element.addClass("wrong-number-report-highlight");
            }, 200);
        }
    });

    // --- 2. RUN INITIALIZATION LOGIC ---
    active_map_type = $("#map_type_selector").val();
    update_version_selector();
    $("#version_selector").trigger("change");
});
```
!END_MODIFICATION report_map.js
