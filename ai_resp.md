I will update your R project to implement the requested features. The changes will enhance the report by adding informative tooltips to table cells, making the discrepancy report interactive, and improving the visual styling for cells with incorrect numbers.

Here is a summary of the plan:
1.  **Modify `rr_map_report` in `R/report_map.R`**: This function will be updated to pre-process data for cell tooltips. It will aggregate information about which regression indices and "wrong number" flags are associated with each table cell across all map versions. This data will be passed to the report's JavaScript.
2.  **Rewrite `inst/www/repbox.css`**: The stylesheet will be updated to remove the old styling for "wrong number" cells and add new styles for the interactive features, including a highlight for cells selected from the discrepancy report and hover effects for the report items.
3.  **Rewrite `inst/www/report_map.js`**: The main JavaScript file will be updated to implement the new features:
    *   It will add detailed tooltips to each table cell on startup.
    *   The styling for cells with discrepancies will be changed to a 45-degree gradient, as requested.
    *   The discrepancy report will be made interactive, allowing users to click on an item to highlight and navigate to the corresponding cell in the table.

These changes will make the generated reports more user-friendly and informative.

!MODIFICATION rr_map_report in report_map.R
scope = "function"
file = "R/report_map.R"
function_name = "rr_map_report"
description = '''Update `rr_map_report` to generate and embed a `cell_info_map`. This map contains aggregated information for each table cell (reg_inds, wrong_number_flags) from all map versions, which is used by JavaScript to create informative tooltips.'''
---
```r
#' Creates an interactive HTML report to visualize maps
#'
#' This function generates a self-contained HTML report that visualizes the
#' maps between Stata do-files and regression tables. The report features
#' static color-coding for regression cells and interactive highlighting.
#'
#' @param project_dir The root directory of the project.
#' @param output_dir Directory for the report. Defaults to 'reports' in project_dir.
#' @param output_file The name of the HTML report file.
#' @param doc_type The document type (e.g., "art", "app1").
#' @param opts A list of options, typically generated by `rr_map_report_opts()`.
#' @return The path to the generated HTML report file.
#' @export
rr_map_report <- function(project_dir,
                          output_dir = file.path(project_dir, "reports"),
                          output_file = "map_report.html",
                          doc_type = "art",
                          opts = NULL) {
  restore.point("rr_map_report")
  # --- 0. Check dependencies & Options ---
  pkgs <- c("dplyr", "tidyr", "stringi", "htmltools", "jsonlite", "purrr", "randtoolbox")
  for (pkg in pkgs) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      stop(paste("Please install the '", pkg, "' package."), call. = FALSE)
    }
  }

  if (is.null(opts)) {
    opts <- rr_map_report_opts()
  }

  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  # --- 1. Setup asset paths ---
  assets_dir <- file.path(output_dir, "shared")
  if (!dir.exists(assets_dir)) {
    dir.create(assets_dir, recursive = TRUE)
  }

  # --- 2. Load data ---
  message("Loading data...")
  parcels <- repboxDB::repdb_load_parcels(project_dir, c("stata_source", "stata_run_cmd", "stata_run_log", "stata_cmd"))

  fp_dir <- file.path(project_dir, "fp", paste0("prod_", doc_type))
  tab_main_info <- rai_pick_tab_ver(fp_dir, "tab_main")
  if(nrow(tab_main_info) == 0) {
      stop("Could not find a suitable 'tab_main' product for doc_type '", doc_type, "'")
  }
  tab_main <- fp_load_prod_df(tab_main_info$ver_dir)

  message("Loading maps...")
  all_map_types <- list()
  prod_id = "map_reg_run"
  for (prod_id in opts$map_prod_ids) {
    map_list <- rr_load_all_map_versions(project_dir, doc_type, prod_id = prod_id)
    if (length(map_list) > 0) {
      all_map_types[[prod_id]] <- map_list
    }
  }
  if (length(all_map_types) == 0) {
    warning("No map versions found for any prod_id in opts$map_prod_ids. The report will be generated without interactive links.")
  }

  # Standardize reg_ind across all map types
  if (length(all_map_types) > 0) {
      message("Standardizing regression indices...")
      # source("R/standardize_reg_ind.R") # This line would be used to load the function
      all_map_types <- rr_standardize_reg_ind(all_map_types)
  }


  # --- 3. Generate HTML & JS components ---
  message("Generating HTML components...")

  # Generate a map of information for each cell_id to be used for tooltips.
  # This is done across all loaded map versions to be comprehensive.
  cell_info_map <- {
    all_map_dfs_for_titles <- unlist(all_map_types, recursive = FALSE)

    # 1. Gather all cell_id -> reg_ind mappings
    reg_mappings <- dplyr::bind_rows(
        purrr::keep(all_map_dfs_for_titles, ~!is.null(.) && all(c("cell_ids", "reg_ind") %in% names(.)))
      ) %>%
      dplyr::filter(!is.na(cell_ids), cell_ids != "", !is.na(reg_ind)) %>%
      dplyr::select(reg_ind, cell_ids) %>%
      dplyr::mutate(cell_id_list = strsplit(as.character(cell_ids), ",")) %>%
      tidyr::unnest(cell_id_list) %>%
      dplyr::mutate(cell_id = trimws(cell_id_list)) %>%
      dplyr::filter(cell_id != "") %>%
      dplyr::select(cell_id, reg_ind) %>%
      dplyr::distinct() %>%
      dplyr::group_by(cell_id) %>%
      dplyr::summarise(reg_inds = list(sort(unique(reg_ind))), .groups = "drop")

    # 2. Gather all cell_ids with wrong numbers
    wrong_number_cells <- dplyr::bind_rows(
        purrr::keep(all_map_dfs_for_titles, ~!is.null(.) && "wrong_number_cases" %in% names(.))
      ) %>%
      dplyr::select(wrong_number_cases) %>%
      dplyr::filter(!sapply(wrong_number_cases, function(x) is.null(x) || NROW(x) == 0)) %>%
      tidyr::unnest(cols = wrong_number_cases) %>%
      dplyr::select(cell_id) %>%
      dplyr::distinct() %>%
      dplyr::mutate(is_wrong = TRUE)

    # 3. Join them together
    cell_info_df <- dplyr::full_join(reg_mappings, wrong_number_cells, by = "cell_id") %>%
      dplyr::mutate(is_wrong = ifelse(is.na(is_wrong), FALSE, is_wrong))

    # 4. Convert to the nested list format for JSON
    if (nrow(cell_info_df) > 0) {
      cell_info_df$reg_inds[sapply(cell_info_df$reg_inds, is.null)] <- list(integer(0))
      purrr::transpose(cell_info_df[, -1]) %>%
        setNames(cell_info_df$cell_id)
    } else {
      list()
    }
  }
  js_cell_info_data <- jsonlite::toJSON(cell_info_map, auto_unbox = TRUE)


  # Generate color map for consistent colors across all loaded maps
  all_map_dfs <- unlist(all_map_types, recursive = FALSE)
  all_reg_inds <- unique(unlist(lapply(all_map_dfs, function(df) if("reg_ind" %in% names(df)) unique(df$reg_ind) else NULL)))
  all_reg_inds <- stats::na.omit(all_reg_inds)
  reg_color_map <- rr_make_distinct_colors(length(all_reg_inds))
  names(reg_color_map) <- all_reg_inds



  # Add a script_file column for easier access
  parcels$stata_source$script_source$script_file <- basename(parcels$stata_source$script_source$file_path)

  do_panel_html <- rr_make_do_panel_html(
    stata_source = parcels$stata_source$script_source,
    stata_cmd = parcels$stata_cmd$stata_cmd,
    stata_run_cmd = parcels$stata_run_cmd$stata_run_cmd,
    stata_run_log = parcels$stata_run_log$stata_run_log,
    opts = opts,
    all_map_types = all_map_types
  )

  tab_panel_html <- rr_make_tab_panel_html(tab_main)
  controls_html <- rr_make_controls_html(all_map_types)

  # --- 4. Write JS and CSS assets ---
  message("Writing JS and CSS assets...")
  rr_copy_pkg_assets(output_dir)

  # --- 5. Generate JS data and Assemble final HTML report ---

  # Conditionally generate map data (embedded vs. external)
  js_maps_data <- "{}"
  js_manifest_data <- "{}"

  if (isTRUE(opts$embed_data)) {
    message("Generating and embedding map data...")
    processed_types <- purrr::map(all_map_types, function(map_list_for_type) {
        purrr::map(map_list_for_type, function(map_df) {
            rr_process_single_map_for_js(map_df, reg_color_map, parcels$stata_source$script_source)
        })
    })
    js_maps_data <- jsonlite::toJSON(processed_types, auto_unbox = TRUE, null = "null", na = "null")
  } else {
    message("Generating external JSON files for map data...")
    maps_data_dir <- file.path(output_dir, "maps_data")
    if (!dir.exists(maps_data_dir)) dir.create(maps_data_dir, recursive = TRUE)

    manifest <- list()
    for (map_type in names(all_map_types)) {
        manifest[[map_type]] <- list()
        for (version_id in names(all_map_types[[map_type]])) {
            map_df <- all_map_types[[map_type]][[version_id]]
            processed_map_list <- rr_process_single_map_for_js(map_df, reg_color_map, parcels$stata_source$script_source)
            json_content <- jsonlite::toJSON(processed_map_list, auto_unbox = TRUE, null = "null", na = "null")

            file_name <- paste0(map_type, "_", version_id, ".json")
            file_path <- file.path(maps_data_dir, file_name)
            relative_path <- file.path("maps_data", file_name)

            writeLines(json_content, file_path)
            manifest[[map_type]][[version_id]] <- relative_path
        }
    }
    js_manifest_data <- jsonlite::toJSON(manifest, auto_unbox = TRUE)
    message("\nExternal JSONs generated. Note: This report must now be viewed via a web server.")
    message("You can start one from R with: servr::httd('", normalizePath(output_dir, mustWork=FALSE), "')")
  }


  message("Assembling final HTML report...")
  html_content <- htmltools::tagList(
    htmltools::tags$head(
      htmltools::tags$meta(charset = "UTF-8"),
      htmltools::tags$meta(`http-equiv` = "X-UA-Compatible", content = "IE=edge"),
      htmltools::tags$meta(name="viewport", content="width=device-width, initial-scale=1"),
      htmltools::tags$title(paste("map Report:", basename(project_dir))),
      htmltools::tags$link(href = "shared/bootstrap.min.css", rel = "stylesheet"),
      htmltools::tags$link(href = "shared/repbox.css", rel = "stylesheet")
    ),
    htmltools::tags$body(
      htmltools::tags$div(class = "container-fluid",
        htmltools::HTML(controls_html),
        htmltools::tags$div(class = "row", style = "height: 95vh;",
          htmltools::tags$div(id = "do-col-div", class = "col-sm-7",
            htmltools::HTML(do_panel_html)
          ),
          htmltools::tags$div(id = "tabs-col-div", class = "col-sm-5",
            htmltools::HTML(tab_panel_html)
          )
        )
      ),
      htmltools::tags$script(src = "shared/jquery.min.js"),
      htmltools::tags$script(src = "shared/bootstrap.min.js"),
      htmltools::tags$script(htmltools::HTML(paste0("var data_is_embedded = ", tolower(isTRUE(opts$embed_data)), ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var all_maps = ", js_maps_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var report_manifest = ", js_manifest_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var cell_info_map = ", js_cell_info_data, ";"))),
      htmltools::tags$script(src = "shared/report_map.js")
    )
  )

  report_path <- file.path(output_dir, output_file)
  htmltools::save_html(html_content, file = report_path)

  message(paste("\nReport generated successfully at:", report_path))
  return(invisible(report_path))
}
```
!END_MODIFICATION rr_map_report in report_map.R

!MODIFICATION repbox.css
scope = "file"
file = "inst/www/repbox.css"
is_new_file = false
description = '''Update `repbox.css` to change styling for 'wrong number' cells and add styles for the interactive discrepancy report.'''
---
```css
/* FILE: repbox.css */
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 14px;
}

/* Layout and Scroll */
#do-col-div {
    display: flex;
    flex-direction: column;
    height: 100%;
    /* Padding: top right bottom left. No padding on the right. */
    padding: 5px 0px 5px 5px;
    /* This column's right border will be the single divider */
    border: 1px solid #ddd;
    /* Adjust border-radius for a seamless join on the right */
    border-radius: 4px 0 0 4px;
}

#tabs-col-div {
    display: flex;
    flex-direction: column;
    height: 100%;
    /* Padding: top right bottom left. No padding on the left. */
    padding: 5px 5px 5px 0px;
    /* No left border to avoid double lines with the other column */
    border-top: 1px solid #ddd;
    border-bottom: 1px solid #ddd;
    border-right: 1px solid #ddd;
    border-left: none;
    /* Adjust border-radius for a seamless join on the left */
    border-radius: 0 4px 4px 0;
}


/* Top Controls Bar */
.controls-div {
    padding: 5px 10px;
    background-color: #f5f5f5;
    border-bottom: 1px solid #ddd;
    margin-bottom: 5px;
}
.controls-div .form-group {
    margin-right: 20px;
}
.controls-div label {
    margin-right: 5px;
    font-weight: normal;
}
.controls-div .form-control {
    height: auto;
    padding: 2px 6px;
}

/* Do File Panel */
.code-tab {
    width: 100%;
    border-collapse: collapse;
}
.code-tab td {
    padding: 0 4px;
    vertical-align: top;
    line-height: 1.2;
}
.code-line-td {
    padding-right: 10px;
    text-align: right;
    color: #888;
    font-family: 'Menlo', 'Monaco', 'Consolas', monospace;
    user-select: none;
}
.do-pre {
    margin: 0;
    padding: 1px 0;
    border: none;
    background-color: transparent;
    white-space: pre-wrap;
    word-wrap: break-word;
    font-family: 'Menlo', 'Monaco', 'Consolas', monospace;
    font-size: 13px;
}
.logtxt-pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 0.9em;
    border: 1px solid #eee;
    padding: 5px;
    background-color: #fdfdfd;
}

/* Line Styles */
.noerr-line { color: #006400; }
.err-line { color: #aa0000; background-color: #fbecec; }
.mida-line { color: #b06900; background-color: #fff3e0; }
.norun-line { color: #555; }
.reg-cmd { font-weight: bold; cursor: pointer; }
.reg-cmd:hover { text-decoration: underline; }

/* Table Panel */
.art-tab-div table {
    font-size: 12px;
    font-family: "Trebuchet MS","Arial Narrow","Tahoma", sans-serif;
    width: auto;
    white-space: nowrap;
    border-collapse: collapse;
    margin-top: 5px;
}
.art-tab-div table td, .art-tab-div table th {
    padding: 2px 4px;
    border: 1px solid #ddd;
    text-align: center;
}
.art-tab-div table th {
    background-color: #f5f5f5;
}
.tabnum, [id^=c][id*=_] {
    cursor: pointer;
}

/* Highlighting */
.code-highlight {
    background-color: #ffd700 !important;
    border-radius: 3px;
}
.cell-highlight {
    background-color: #ffd700 !important;
    outline: 2px solid #e0b800 !important;
}
.statically-colored {
    /* Use a CSS variable for the background color. Set with JS. */
    /* !important ensures this style overrides any other conflicting rules (e.g., from bootstrap) */
    background-color: var(--static-bg-color) !important;
    transition: background-color 0.3s ease;
}


/* Tab Styles */
.nav-pills>li>a {
    padding: 4px 8px;
}
.small-tab-ul {
    font-size: 0.8em;
}
.small-tab-ul>li>a {
    padding: 3px 6px;
}
.tab-content {
    border: 1px solid #ddd;
    padding: 5px;
    border-top: none;
    border-radius: 0 0 4px 4px;
}
#dotabs + .tab-content,
#tabtabs + .tab-content {
    flex: 1;
    min-height: 0; /* Prevents flexbox overflow issues */
    overflow-y: auto;
}

/* Discrepancy Highlighting */
.wrong-number-cell {
    /* This class is now just a marker. Styling is applied via JS using a gradient. */
}

/* For interactive report click */
.wrong-number-report-highlight {
    outline: 2px solid red !important;
    outline-offset: -2px;
}

.wrong-number-report {
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #f0c0c0;
    background-color: #fef5f5;
    border-radius: 4px;
    font-size: 13px;
    white-space: normal;
    text-align: left;
}
.wrong-number-report h6 {
    margin-top: 0;
    font-weight: bold;
    color: #a94442;
}
.wrong-number-report ul {
    padding-left: 20px;
    margin-bottom: 0;
}
.wrong-number-report-item {
    cursor: pointer;
    list-style-type: disc;
    margin-bottom: 2px;
}
.wrong-number-report-item:hover {
    text-decoration: underline;
    color: #337ab7;
}
```
!END_MODIFICATION repbox.css

!MODIFICATION report_map.js
scope = "file"
file = "inst/www/report_map.js"
is_new_file = false
description = '''Rewrite `report_map.js` to add cell tooltips, interactive discrepancy reports, and improved styling for wrong-number cells.'''
---
```javascript
// FILE: report_map.js

// Global variables set by the R backend
// var data_is_embedded = true;
// var all_maps = { ... }; // Populated if data_is_embedded is true
// var report_manifest = { ... }; // Populated if data_is_embedded is false
// var cell_info_map = { ... }; // Populated with aggregated cell info

var active_map_type = "";
var active_version = "";
var active_mapping = {};

var last_code_highlight = "";
var last_cell_highlights = [];

function clear_all_highlights() {
    if (last_code_highlight) {
        $(last_code_highlight).removeClass("code-highlight");
        last_code_highlight = "";
    }
    last_cell_highlights.forEach(function(id) {
        $(id).removeClass("cell-highlight");
    });
    last_cell_highlights = [];
    // Also clear highlights from discrepancy report clicks
    $(".wrong-number-report-highlight").removeClass("wrong-number-report-highlight");
}

function clear_static_coloring() {
    // We must iterate over each element to remove the specific style
    // property that was set with '!important'. Standard .css() won't work.
    $(".statically-colored").each(function() {
        this.style.removeProperty('background-color');
        $(this).removeClass("statically-colored");
    });
}

function apply_static_coloring(mapping) {
    clear_static_coloring();
    if (!mapping || !mapping.reg_info) return;

    const reg_info = mapping.reg_info;
    for (const reg_ind in reg_info) {
        if (reg_info.hasOwnProperty(reg_ind)) {
            const info = reg_info[reg_ind];
            if (info.color && info.cell_ids) {
                const cell_ids = info.cell_ids.split(',');
                cell_ids.forEach(id => {
                    const cell_selector = "#" + id.trim();
                    const element = $(cell_selector);

                    if (element.length > 0) {
                        // Use the DOM element's setProperty method to add '!important'.
                        // This ensures our coloring rule has the highest priority and will
                        // override any conflicting styles (like from Bootstrap or other CSS).
                        element[0].style.setProperty('background-color', info.color, 'important');
                        element.addClass('statically-colored');
                    }
                });
            }
        }
    }
}

function apply_wrong_number_info(mapping) {
    // Clear previous reports and styling
    $(".wrong-number-report").remove();
    $(".wrong-number-cell").each(function() {
        this.style.removeProperty('background-image');
        $(this).removeClass("wrong-number-cell");
    });

    if (!mapping || !mapping.wrong_number_info || !Array.isArray(mapping.wrong_number_info) || mapping.wrong_number_info.length === 0) {
        return;
    }

    // Build a map from cell ID to its regression color for this specific map version
    const cell_to_color = {};
    if (mapping.reg_info) {
        for (const reg_ind in mapping.reg_info) {
            const info = mapping.reg_info[reg_ind];
            if (info.color && info.cell_ids) {
                info.cell_ids.split(',').forEach(id => {
                    cell_to_color[id.trim()] = info.color;
                });
            }
        }
    }

    const wrong_cases_by_tab = {};
    mapping.wrong_number_info.forEach(case_item => {
        const tabid = String(case_item.tabid); // Ensure tabid is a string
        if (!wrong_cases_by_tab[tabid]) {
            wrong_cases_by_tab[tabid] = [];
        }
        wrong_cases_by_tab[tabid].push(case_item);

        // Apply styling to the cell
        const cell_element = $("#" + case_item.cell_id);
        if (cell_element.length > 0) {
            cell_element.addClass("wrong-number-cell");
            const reg_color = cell_to_color[case_item.cell_id] || '#f0f0f0'; // Default color if not found
            const gradient = `linear-gradient(45deg, #cccccc, ${reg_color})`;
            // This will be rendered on top of the background-color set by static coloring
            cell_element[0].style.setProperty('background-image', gradient, 'important');
        }
    });

    // Generate and append reports for each table that has wrong numbers
    for (const tabid in wrong_cases_by_tab) {
        if (wrong_cases_by_tab.hasOwnProperty(tabid)) {
            const cases_for_tab = wrong_cases_by_tab[tabid];
            let report_html = '<div class="wrong-number-report">';
            report_html += '<h6>Discrepancies Found (click to locate):</h6><ul>';
            cases_for_tab.forEach(case_item => {
                report_html += `<li class="wrong-number-report-item" data-cell-id="${case_item.cell_id}">Cell <code>${case_item.cell_id}</code>: Table shows ${case_item.wrong_number_in_cell}, but script output is ${case_item.number_in_stata_output}.</li>`;
            });
            report_html += '</ul></div>';

            // Find the correct table div to append to
            const table_container = $("#tabtab" + tabid + " .art-tab-div");
            if (table_container.length > 0) {
                table_container.append(report_html);
            }
        }
    }
}


function highlight_code(script_num, line_num) {
    $("#dotabs a[href='#dotab_" + script_num + "']").tab("show");

    // Defer actions to allow tab to show first
    setTimeout(function() {
        const code_id = "#L" + line_num + "___" + script_num;
        $(code_id).addClass("code-highlight");
        last_code_highlight = code_id;

        const targetElement = document.querySelector(code_id);
        if(targetElement) {
            targetElement.scrollIntoView({ behavior: "smooth", block: "center" });
        }
    }, 150);
}

function highlight_cells(tabid, cell_ids_string) {
    if (!tabid || !cell_ids_string) return;
    $("#tabtabs a[href='#tabtab" + tabid + "']").tab("show");

    setTimeout(function() {
        const cell_ids = cell_ids_string.split(",");
        cell_ids.forEach(id => {
            const cell_selector = "#" + id.trim();
            $(cell_selector).addClass("cell-highlight");
            last_cell_highlights.push(cell_selector);
        });
        if (cell_ids.length > 0) {
            const targetElement = document.querySelector("#" + cell_ids[0].trim());
            if(targetElement) {
               targetElement.scrollIntoView({ behavior: "smooth", block: "center" });
            }
        }
    }, 150);
}

// Function to update the version selector based on the active map type
function update_version_selector() {
    // The source of map keys depends on the data loading mode.
    const source = data_is_embedded ? all_maps : report_manifest;
    const versions = Object.keys(source[active_map_type] || {});
    const version_selector = $("#version_selector");
    version_selector.empty();
    versions.forEach(function(v) {
        version_selector.append($("<option></option>").attr("value", v).text(v));
    });
}

function applyCellTitles() {
    // cell_info_map is loaded from the HTML script tag
    if (typeof cell_info_map === 'undefined' || Object.keys(cell_info_map).length === 0) return;

    // Iterate over all potential table cells
    $("[id^=c][id*=_]").each(function() {
        const cell_id = this.id;
        const info = cell_info_map[cell_id];
        let title_parts = [`cell_id: ${cell_id}`];

        if (info) {
            if (info.reg_inds && info.reg_inds.length > 0) {
                // reg_inds are already sorted and unique from R
                title_parts.push(`reg_ind(s): ${info.reg_inds.join(', ')}`);
                if (info.reg_inds.length > 1) {
                    title_parts.push('(Note: Mapped to multiple regressions across different map versions)');
                }
            }
            if (info.is_wrong) {
                title_parts.push('(Note: Marked as having a wrong number in at least one map version)');
            }
        }
        $(this).attr('title', title_parts.join('\n'));
    });
}


$(document).ready(function() {
    const map_types = Object.keys(data_is_embedded ? all_maps : report_manifest);
    if (map_types.length === 0) {
        $(".controls-div").hide();
        return;
    }

    // --- 1. DEFINE EVENT HANDLERS FIRST ---

    // Change map type
    $("#map_type_selector").on("change", function() {
        active_map_type = $(this).val();
        update_version_selector();
        // Trigger the version change to update the mapping and view
        $("#version_selector").trigger("change");
    });

    // Change map version
    $("#version_selector").on("change", function() {
        active_version = $(this).val();
        clear_all_highlights();

        if (data_is_embedded) {
            // EMBEDDED MODE: Simply look up the data in the global object
            if (active_map_type && active_version && all_maps[active_map_type] && all_maps[active_map_type][active_version]) {
                active_mapping = all_maps[active_map_type][active_version];
            } else {
                active_mapping = {};
            }
            apply_static_coloring(active_mapping);
            apply_wrong_number_info(active_mapping);
        } else {
            // EXTERNAL MODE: Fetch the data from the corresponding JSON file
            const file_path = report_manifest[active_map_type]?.[active_version];
            if (!file_path) {
                active_mapping = {};
                apply_static_coloring(active_mapping);
                apply_wrong_number_info(active_mapping);
                return;
            }

            const selectors = $("#map_type_selector, #version_selector");
            selectors.prop("disabled", true); // Disable controls during fetch

            fetch(file_path)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    active_mapping = data;
                    apply_static_coloring(active_mapping);
                    apply_wrong_number_info(active_mapping);
                })
                .catch(error => {
                    console.error("Failed to fetch map data:", error);
                    alert("Failed to load map data. Please ensure you are viewing this report via a web server and the file exists: " + file_path);
                    active_mapping = {};
                    apply_static_coloring(active_mapping);
                    apply_wrong_number_info(active_mapping);
                })
                .finally(() => {
                    selectors.prop("disabled", false); // Re-enable controls
                });
        }
    });

    // Click on a table cell
    $(document).on("click", ".tabnum, [id^=c][id*=_]", function(event) {
        clear_all_highlights();
        const cell_id = event.currentTarget.id;

        // Check for the new properties in the active mapping
        if (active_mapping && active_mapping.cell_to_code_idx && active_mapping.code_locations) {
            // Find the index for our cell's code location
            const location_idx = active_mapping.cell_to_code_idx[cell_id];

            // Check that the index is valid (not undefined)
            if (typeof location_idx !== 'undefined') {
                // Retrieve the location data using the index
                const location_data = active_mapping.code_locations[location_idx];
                // location_data is an array: [runid, script_num, code_line]

                $(event.currentTarget).addClass("cell-highlight");
                last_cell_highlights.push("#" + cell_id);

                // Access data by index
                const script_num = location_data[1];
                const code_line = location_data[2];
                highlight_code(script_num, code_line);
            }
        }
    });

    // Click on a regression command in a do-file
    $(document).on("click", ".reg-cmd", function(event) {
        clear_all_highlights();
        const code_el = $(event.currentTarget);
        const code_id_parts = code_el.attr("id").split("___");
        const line = code_id_parts[0].substring(1);
        const script_num = code_id_parts[1];
        const lookup_key = "s" + script_num + "_l" + line;

        if (active_mapping && active_mapping.code_to_cells && active_mapping.code_to_cells[lookup_key]) {
            const mapping = active_mapping.code_to_cells[lookup_key];
            code_el.addClass("code-highlight");
            last_code_highlight = "#" + code_el.attr("id");
            highlight_cells(mapping.tabid, mapping.cell_ids);
        }
    });

    // Click on an item in the discrepancy report
    $(document).on("click", ".wrong-number-report-item", function() {
        clear_all_highlights();

        const cell_id = $(this).data("cell-id");
        if (!cell_id) return;

        const cell_element = $("#" + cell_id);
        if (cell_element.length > 0) {
            const tab_pane = cell_element.closest('.tab-pane[id^=tabtab]');
            if (tab_pane.length > 0) {
                const tab_id = tab_pane.attr('id');
                $('#tabtabs a[href="#' + tab_id + '"]').tab('show');
            }

            // Defer scroll and highlight to ensure tab is visible
            setTimeout(function() {
                cell_element[0].scrollIntoView({ behavior: "smooth", block: "center" });
                cell_element.addClass("wrong-number-report-highlight");
            }, 200);
        }
    });

    // --- 2. RUN INITIALIZATION LOGIC ---

    // Apply titles to table cells (this is static for the report)
    applyCellTitles();

    // Set the initial map type from the first option in the selector
    active_map_type = $("#map_type_selector").val();

    // Populate the version selector based on the initial map type
    update_version_selector();

    // Now, trigger the change event on the version selector.
    // Since the handler is already attached, this will correctly
    // set the initial active_mapping and apply static colors (or fetch data).
    $("#version_selector").trigger("change");
});
```
!END_MODIFICATION report_map.js
