# FILE: report_map.R

example = function() {
  # The project_dir needs to be set to a valid repbox project
  project_dir = "/home/rstudio/repbox/projects_gha_new/aejapp_10_4_6"
  # Generate report with default options (embedded data)
  opts = rr_map_report_opts(embed_data = FALSE)
  rep_file = rr_map_report(project_dir,opts = opts)
  browseURL(rep_file)

  # Example with external JSON files
  # This report will need to be viewed via a web server.
  opts <- rr_map_report_opts(embed_data = FALSE)
  opts$output_for <- "all"
  output_dir_ext = file.path(project_dir, "reports_external")
  rr_map_report(project_dir, opts = opts, output_dir = output_dir_ext, output_file = "map_report_full_logs.html")
  # To view, you would run this in the R console:
  # servr::httd(output_dir_ext)

  rstudioapi::filesPaneNavigate(project_dir)
}

#' This function provides a list of default settings that can be passed to `rr_map_report`.
#'
#' **Options:**
#' * `output_for`: Determines for which commands the log output is shown.
#'   - `"reg"`: Show output only for regression commands (`is_reg=TRUE`).
#'   - `"reg_and_map"`: (Default) Show output for all regression commands and for all other commands that are part of a map.
#'   - `"all"`: Show output for all executed commands.
#'   - `"none"`: Do not show any log output.
#' * `map_prod_ids`: A character vector of map product IDs to load and display in the report. The user can switch between these map types in the UI.
#' * `embed_data`: A logical value. If `TRUE` (default), all map data is embedded into a single self-contained HTML file. If `FALSE`, map data is written to external JSON files, which makes the initial report load faster but requires a web server for viewing.
#'
#' @return A list of default options.
#' @export
rr_map_report_opts <- function(output_for = c("all", "reg", "reg_and_map", "none")[3],
                             map_prod_ids = c("map_reg_run", "map_inv_reg_run", "map_reg_static"),
                             embed_data = TRUE) {
  as.list(environment())
}


#' Creates an interactive HTML report to visualize maps
#'
#' This function generates a self-contained HTML report that visualizes the
#' maps between Stata do-files and regression tables. The report features
#' static color-coding for regression cells and interactive highlighting.
#'
#' @param project_dir The root directory of the project.
#' @param output_dir Directory for the report. Defaults to 'reports' in project_dir.
#' @param output_file The name of the HTML report file.
#' @param doc_type The document type (e.g., "art", "app1").
#' @param opts A list of options, typically generated by `rr_map_report_opts()`.
#' @return The path to the generated HTML report file.
#' @export
rr_map_report <- function(project_dir,
                          output_dir = file.path(project_dir, "reports"),
                          output_file = "map_report.html",
                          doc_type = "art",
                          opts = NULL) {
  restore.point("rr_map_report")
  # --- 0. Check dependencies & Options ---
  pkgs <- c("dplyr", "tidyr", "stringi", "htmltools", "jsonlite", "purrr", "randtoolbox")
  for (pkg in pkgs) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      stop(paste("Please install the '", pkg, "' package."), call. = FALSE)
    }
  }

  if (is.null(opts)) {
    opts <- rr_map_report_opts()
  }

  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  # --- 1. Setup asset paths ---
  assets_dir <- file.path(output_dir, "shared")
  if (!dir.exists(assets_dir)) {
    dir.create(assets_dir, recursive = TRUE)
  }

  # --- 2. Load data ---
  message("Loading data...")
  parcels <- repboxDB::repdb_load_parcels(project_dir, c("stata_source", "stata_run_cmd", "stata_run_log", "stata_cmd"))

  fp_dir <- file.path(project_dir, "fp", paste0("prod_", doc_type))
  tab_main_info <- rai_pick_tab_ver(fp_dir, "tab_main")
  if(nrow(tab_main_info) == 0) {
      stop("Could not find a suitable 'tab_main' product for doc_type '", doc_type, "'")
  }
  tab_main <- fp_load_prod_df(tab_main_info$ver_dir)

  message("Loading maps...")
  all_map_types <- list()
  prod_id = "map_reg_run"
  for (prod_id in opts$map_prod_ids) {
    map_list <- rr_load_all_map_versions(project_dir, doc_type, prod_id = prod_id)
    if (length(map_list) > 0) {
      all_map_types[[prod_id]] <- map_list
    }
  }
  if (length(all_map_types) == 0) {
    warning("No map versions found for any prod_id in opts$map_prod_ids. The report will be generated without interactive links.")
  }

  # Standardize reg_ind across all map types
  if (length(all_map_types) > 0) {
      message("Standardizing regression indices...")
      # source("R/standardize_reg_ind.R") # This line would be used to load the function
      all_map_types <- rr_standardize_reg_ind(all_map_types)
  }


  # --- 3. Generate HTML & JS components ---
  message("Generating HTML components...")

  # Generate a map of information for each cell_id to be used for tooltips.
  # This is done across all loaded map versions to be comprehensive.
  cell_info_map <- {
    all_map_dfs_for_titles <- unlist(all_map_types, recursive = FALSE)

    # 1. Gather all cell_id -> reg_ind mappings
    reg_mappings <- dplyr::bind_rows(
        purrr::keep(all_map_dfs_for_titles, ~!is.null(.) && all(c("cell_ids", "reg_ind") %in% names(.)))
      ) %>%
      dplyr::filter(!is.na(cell_ids), cell_ids != "", !is.na(reg_ind)) %>%
      dplyr::select(reg_ind, cell_ids) %>%
      dplyr::mutate(cell_id_list = strsplit(as.character(cell_ids), ",")) %>%
      tidyr::unnest(cell_id_list) %>%
      dplyr::mutate(cell_id = trimws(cell_id_list)) %>%
      dplyr::filter(cell_id != "") %>%
      dplyr::select(cell_id, reg_ind) %>%
      dplyr::distinct() %>%
      dplyr::group_by(cell_id) %>%
      dplyr::summarise(reg_inds = list(sort(unique(reg_ind))), .groups = "drop")

    # 2. Gather all cell_ids with wrong numbers
    wrong_number_cells <- dplyr::bind_rows(
        purrr::keep(all_map_dfs_for_titles, ~!is.null(.) && "wrong_number_cases" %in% names(.))
      ) %>%
      dplyr::select(wrong_number_cases) %>%
      dplyr::filter(!sapply(wrong_number_cases, function(x) is.null(x) || NROW(x) == 0)) %>%
      tidyr::unnest(cols = wrong_number_cases) %>%
      dplyr::select(cell_id) %>%
      dplyr::distinct() %>%
      dplyr::mutate(is_wrong = TRUE)

    # 3. Join them together
    cell_info_df <- dplyr::full_join(reg_mappings, wrong_number_cells, by = "cell_id") %>%
      dplyr::mutate(is_wrong = ifelse(is.na(is_wrong), FALSE, is_wrong))

    # 4. Convert to the nested list format for JSON
    if (nrow(cell_info_df) > 0) {
      cell_info_df$reg_inds[sapply(cell_info_df$reg_inds, is.null)] <- list(integer(0))
      purrr::transpose(cell_info_df[, -1]) %>%
        setNames(cell_info_df$cell_id)
    } else {
      list()
    }
  }
  js_cell_info_data <- jsonlite::toJSON(cell_info_map, auto_unbox = TRUE)


  # Generate color map for consistent colors across all loaded maps
  all_map_dfs <- unlist(all_map_types, recursive = FALSE)
  all_reg_inds <- unique(unlist(lapply(all_map_dfs, function(df) if("reg_ind" %in% names(df)) unique(df$reg_ind) else NULL)))
  all_reg_inds <- stats::na.omit(all_reg_inds)
  reg_color_map <- rr_make_distinct_colors(length(all_reg_inds))
  names(reg_color_map) <- all_reg_inds



  # Add a script_file column for easier access
  parcels$stata_source$script_source$script_file <- basename(parcels$stata_source$script_source$file_path)

  do_panel_html <- rr_make_do_panel_html(
    stata_source = parcels$stata_source$script_source,
    stata_cmd = parcels$stata_cmd$stata_cmd,
    stata_run_cmd = parcels$stata_run_cmd$stata_run_cmd,
    stata_run_log = parcels$stata_run_log$stata_run_log,
    opts = opts,
    all_map_types = all_map_types
  )

  tab_panel_html <- rr_make_tab_panel_html(tab_main)
  controls_html <- rr_make_controls_html(all_map_types)

  # --- 4. Write JS and CSS assets ---
  message("Writing JS and CSS assets...")
  rr_copy_pkg_assets(output_dir)

  # --- 5. Generate JS data and Assemble final HTML report ---

  # Conditionally generate map data (embedded vs. external)
  js_maps_data <- "{}"
  js_manifest_data <- "{}"

  if (isTRUE(opts$embed_data)) {
    message("Generating and embedding map data...")
    processed_types <- purrr::map(all_map_types, function(map_list_for_type) {
        purrr::map(map_list_for_type, function(map_df) {
            rr_process_single_map_for_js(map_df, reg_color_map, parcels$stata_source$script_source)
        })
    })
    js_maps_data <- jsonlite::toJSON(processed_types, auto_unbox = TRUE, null = "null", na = "null")
  } else {
    message("Generating external JSON files for map data...")
    maps_data_dir <- file.path(output_dir, "maps_data")
    if (!dir.exists(maps_data_dir)) dir.create(maps_data_dir, recursive = TRUE)

    manifest <- list()
    for (map_type in names(all_map_types)) {
        manifest[[map_type]] <- list()
        for (version_id in names(all_map_types[[map_type]])) {
            map_df <- all_map_types[[map_type]][[version_id]]
            processed_map_list <- rr_process_single_map_for_js(map_df, reg_color_map, parcels$stata_source$script_source)
            json_content <- jsonlite::toJSON(processed_map_list, auto_unbox = TRUE, null = "null", na = "null")

            file_name <- paste0(map_type, "_", version_id, ".json")
            file_path <- file.path(maps_data_dir, file_name)
            relative_path <- file.path("maps_data", file_name)

            writeLines(json_content, file_path)
            manifest[[map_type]][[version_id]] <- relative_path
        }
    }
    js_manifest_data <- jsonlite::toJSON(manifest, auto_unbox = TRUE)
    message("\nExternal JSONs generated. Note: This report must now be viewed via a web server.")
    message("You can start one from R with: servr::httd('", normalizePath(output_dir, mustWork=FALSE), "')")
  }


  message("Assembling final HTML report...")
  html_content <- htmltools::tagList(
    htmltools::tags$head(
      htmltools::tags$meta(charset = "UTF-8"),
      htmltools::tags$meta(`http-equiv` = "X-UA-Compatible", content = "IE=edge"),
      htmltools::tags$meta(name="viewport", content="width=device-width, initial-scale=1"),
      htmltools::tags$title(paste("map Report:", basename(project_dir))),
      htmltools::tags$link(href = "shared/bootstrap.min.css", rel = "stylesheet"),
      htmltools::tags$link(href = "shared/repbox.css", rel = "stylesheet")
    ),
    htmltools::tags$body(
      htmltools::tags$div(class = "container-fluid",
        htmltools::HTML(controls_html),
        htmltools::tags$div(class = "row", style = "height: 95vh;",
          htmltools::tags$div(id = "do-col-div", class = "col-sm-7",
            htmltools::HTML(do_panel_html)
          ),
          htmltools::tags$div(id = "tabs-col-div", class = "col-sm-5",
            htmltools::HTML(tab_panel_html)
          )
        )
      ),
      htmltools::tags$script(src = "shared/jquery.min.js"),
      htmltools::tags$script(src = "shared/bootstrap.min.js"),
      htmltools::tags$script(htmltools::HTML(paste0("var data_is_embedded = ", tolower(isTRUE(opts$embed_data)), ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var all_maps = ", js_maps_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var report_manifest = ", js_manifest_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var cell_info_map = ", js_cell_info_data, ";"))),
      htmltools::tags$script(src = "shared/report_map.js")
    )
  )

  report_path <- file.path(output_dir, output_file)
  htmltools::save_html(html_content, file = report_path)

  message(paste("\nReport generated successfully at:", report_path))
  return(invisible(report_path))
}


# --- Helper Functions ---

#' @noRd
#' @description Robustly adds script_num to a map data frame by joining on
#' full path and then falling back to basename.
#' @param map_df The map data frame, which must contain a 'script_file' column.
#' @param stata_source The 'script_source' data frame from parcels.
#' @return The map_df with an added 'script_num' column.
rr_robust_script_num_join <- function(map_df, stata_source) {
  if (is.null(map_df) || nrow(map_df) == 0) return(map_df)
  if (!"script_file" %in% names(map_df)) return(map_df)

  # If script_num exists and is fully populated, we are done
  if ("script_num" %in% names(map_df) && !any(is.na(map_df$script_num))) return(map_df)

  # If script_num column exists but has NAs, remove it to be re-created cleanly.
  if ("script_num" %in% names(map_df)) {
    map_df <- map_df %>% dplyr::select(-.data$script_num)
  }

  script_info <- stata_source %>%
    dplyr::select(.data$file_path, .data$script_num) %>%
    dplyr::distinct() %>%
    dplyr::mutate(script_basename = basename(.data$file_path))

  # Attempt 1: Join by full path
  map_df_with_num_path <- map_df %>%
    dplyr::left_join(script_info %>% dplyr::select(.data$file_path, .data$script_num), by = c("script_file" = "file_path"))

  # Attempt 2: Join by basename
  script_info_basename_lookup <- script_info %>%
    dplyr::select(script_basename = .data$script_basename, script_num_base = .data$script_num)
  if (any(duplicated(script_info_basename_lookup$script_basename))) {
    warning("Duplicate script basenames found. Matching by basename may be ambiguous. Taking first match.")
    script_info_basename_lookup <- script_info_basename_lookup %>%
      dplyr::distinct(.data$script_basename, .keep_all = TRUE)
  }

  map_df_with_num_base <- map_df %>%
    dplyr::left_join(script_info_basename_lookup, by = c("script_file" = "script_basename"))

  # Coalesce the results. script_num from path join takes precedence.
  map_df$script_num <- dplyr::coalesce(map_df_with_num_path$script_num, map_df_with_num_base$script_num_base)

  return(map_df)
}
# Helper to process a single map data frame into a JS-ready list structure
rr_process_single_map_for_js <- function(map_df, reg_color_map, stata_source) {
    restore.point("rr_process_single_map_for_js")
    if (is.null(map_df) || nrow(map_df) == 0) {
      # Return the new empty structure
      return(list(code_locations = list(), cell_to_code_idx = list(),
                  code_to_cells = list(), reg_info = setNames(list(), character(0)),
                  wrong_number_info = list()))
    }

    # Robustly join to get script_num
    map_df <- rr_robust_script_num_join(map_df, stata_source)

    ensure_cols <- c("runid", "script_num", "code_line", "cell_ids", "tabid", "reg_ind")
    for (col in ensure_cols) {
      if (!col %in% names(map_df)) {
        map_df[[col]] <- if (col %in% c("runid", "script_num", "code_line", "reg_ind")) NA_integer_ else NA_character_
      }
    }

    # --- NEW LOGIC FOR COMPACT CELL->CODE MAPPING ---
    cell_map_df <- map_df %>%
      dplyr::filter(!is.na(.data$cell_ids), .data$cell_ids != "", !is.na(.data$script_num), !is.na(.data$code_line)) %>%
      dplyr::mutate(cell_id = strsplit(as.character(.data$cell_ids), ",")) %>%
      tidyr::unnest(.data$cell_id) %>%
      dplyr::mutate(cell_id = trimws(.data$cell_id)) %>%
      dplyr::select(.data$cell_id, .data$runid, .data$script_num, .data$code_line)

    if (nrow(cell_map_df) > 0) {
        # 1. Find unique code locations and assign a 0-based index
        unique_locations <- cell_map_df %>%
          dplyr::select(.data$runid, .data$script_num, .data$code_line) %>%
          dplyr::distinct() %>%
          dplyr::arrange(.data$runid, .data$script_num, .data$code_line) %>%
          dplyr::mutate(location_idx = dplyr::row_number() - 1)

        # 2. Create the list of location arrays for JSON
        code_locations_list <- purrr::pmap(unique_locations[, c("runid", "script_num", "code_line")], c)

        # 3. Join back to get the index for each cell and create the named list
        cell_to_idx_df <- dplyr::left_join(cell_map_df, unique_locations, by = c("runid", "script_num", "code_line"))
        cell_to_code_idx <- setNames(as.list(cell_to_idx_df$location_idx), cell_to_idx_df$cell_id)
    } else {
        code_locations_list <- list()
        cell_to_code_idx <- list()
    }
    # --- END OF NEW LOGIC ---

    code_map_df <- map_df %>%
      dplyr::filter(!is.na(.data$code_line), !is.na(.data$script_num)) %>%
      dplyr::select(.data$script_num, .data$code_line, .data$tabid, .data$cell_ids) %>%
      dplyr::distinct()
    code_to_cells <- if (nrow(code_map_df) > 0) setNames(lapply(1:nrow(code_map_df), function(i) as.list(code_map_df[i, c("tabid", "cell_ids")])), paste0("s", code_map_df$script_num, "_l", code_map_df$code_line)) else list()
    reg_info <- setNames(list(), character(0))
    if ("reg_ind" %in% names(map_df) && length(reg_color_map) > 0) {
      reg_df <- map_df %>%
        dplyr::filter(!is.na(.data$reg_ind), !is.na(.data$cell_ids), .data$cell_ids != "") %>%
        dplyr::select(.data$reg_ind, .data$cell_ids) %>%
        dplyr::group_by(.data$reg_ind) %>%
        dplyr::summarise(all_cell_ids = paste(unique(trimws(unlist(strsplit(.data$cell_ids, ",")))), collapse = ","), .groups = "drop")
      if (nrow(reg_df) > 0) {
        reg_info_list <- lapply(1:nrow(reg_df), function(i) {
            reg_index_char <- as.character(reg_df$reg_ind[i])
            if (reg_index_char %in% names(reg_color_map)) list(color = reg_color_map[[reg_index_char]], cell_ids = reg_df$all_cell_ids[i]) else NULL
          })
        names(reg_info_list) <- reg_df$reg_ind
        reg_info <- reg_info_list[!sapply(reg_info_list, is.null)]
      }
    }

    # --- Process wrong number cases ---
    wrong_number_info <- list()
    if ("wrong_number_cases" %in% names(map_df) && "tabid" %in% names(map_df)) {
        # The list column from JSON can contain NULLs for empty arrays. Filter these out.
        wnc_df <- map_df %>%
            dplyr::select(.data$tabid, .data$wrong_number_cases) %>%
            dplyr::filter(!sapply(.data$wrong_number_cases, function(x) is.null(x) || NROW(x) == 0))

        if (nrow(wnc_df) > 0) {
            wrong_number_info <- wnc_df %>%
                tidyr::unnest(cols = .data$wrong_number_cases) %>%
                dplyr::select(
                    .data$tabid,
                    .data$cell_id,
                    .data$wrong_number_in_cell,
                    .data$number_in_stata_output
                ) %>%
                dplyr::distinct()
        }
    }


    # Return the new structure
    list(
      code_locations = code_locations_list,
      cell_to_code_idx = cell_to_code_idx,
      code_to_cells = code_to_cells,
      reg_info = reg_info,
      wrong_number_info = wrong_number_info
    )
}


#' @describeIn rr_map_report Load all available versions of a given product.
rr_load_all_map_versions <- function(project_dir, doc_type, prod_id) {
  restore.point("rr_load_all_map_versions")
  fp_dir <- file.path(project_dir, "fp", paste0("prod_", doc_type))
  prod_path <- file.path(fp_dir, prod_id)
  if (!dir.exists(prod_path)) return(list())


  ver_dirs = fp_all_ok_ver_dirs(fp_dir,prod_id = prod_id)
  if (length(ver_dirs) == 0) return(list())

  df_list <- lapply(ver_dirs, function(ver_dir) {
    ver_id = fp_ver_dir_to_proc_id(ver_dir)
    df = fp_load_prod_df(ver_dir)
    df
  })
  ind_df = fp_ver_dir_to_ids(ver_dirs) %>%
    mutate(name = ifelse(ver_ind >0, ver_id, proc_id))
  names(df_list) = ind_df$name
  df_list

}

# NOTE: rr_make_js_maps_data is now obsolete and has been replaced by an
# internal helper function and logic within rr_map_report.

#' @describeIn rr_map_report Generate HTML for the Stata do-file panel.
rr_make_do_panel_html <- function(stata_source, stata_cmd, stata_run_cmd, stata_run_log, opts, all_map_types = NULL) {
  restore.point("rr_make_do_panel_html")
  # --- Data Preparation ---
  run_df <- stata_run_cmd %>%
    dplyr::left_join(stata_source %>% dplyr::select(artid, file_path, script_num), by=c("artid", "file_path")) %>%
    dplyr::left_join(stata_run_log, by = c("artid", "runid", "script_num"))

  ldf <- stata_source %>%
    dplyr::mutate(text_lines = stringi::stri_split_lines(text)) %>%
    dplyr::select(script_num, file_path, text_lines) %>%
    tidyr::unnest(text_lines) %>%
    dplyr::group_by(script_num) %>%
    dplyr::mutate(orgline = dplyr::row_number()) %>%
    dplyr::ungroup()

  cmd_info <- stata_cmd %>%
    dplyr::select(file_path, line, orgline_start, orgline_end, is_reg) %>%
    dplyr::mutate(orgline = purrr::map2(orgline_start, orgline_end, seq)) %>%
    tidyr::unnest(orgline)

  ldf <- dplyr::left_join(ldf, cmd_info, by = c("file_path", "orgline"))

  run_info <- run_df %>%
    dplyr::group_by(file_path, line) %>%
    dplyr::summarise(runs = list(dplyr::tibble(runid = runid, logtxt = logtxt, errcode = errcode, missing_data = missing_data)), .groups = "drop")

  first_lines <- stata_cmd %>%
    dplyr::select(file_path, line, orgline = orgline_start) %>%
    dplyr::distinct() %>%
    dplyr::left_join(run_info, by = c("file_path", "line"))

  ldf <- dplyr::left_join(ldf, first_lines, by = c("file_path", "line", "orgline"))

  # --- Filter log output based on opts ---
  if (!is.null(opts$output_for)) {
    if (opts$output_for == "none") {
      ldf$runs <- list(NULL)
    } else if (opts$output_for == "reg") {
      # is_reg can be NA, so is.true is correct
      ldf$runs[!is.true(ldf$is_reg)] <- list(NULL)
    } else if (opts$output_for == "reg_and_map" && !is.null(all_map_types)) {
      # Get all mapped lines from all_map_types
      all_map_dfs <- unlist(all_map_types, recursive = FALSE)
      all_map_dfs <- all_map_dfs[sapply(all_map_dfs, function(df) !is.null(df) && nrow(df) > 0)]

      if (length(all_map_dfs) > 0) {

        # Use the robust join function to add script_num if missing.
        # 'stata_source' is available from the parent function's arguments.
        all_map_dfs_norm <- lapply(all_map_dfs, function(df) {
          rr_robust_script_num_join(df, stata_source)
        })

        # The map's 'code_line' corresponds to the original line number ('orgline')
        mapped_orglines_df <- dplyr::bind_rows(all_map_dfs_norm) %>%
          dplyr::filter(!is.na(.data$script_num), !is.na(.data$code_line)) %>%
          dplyr::select(script_num, orgline = .data$code_line) %>%
          dplyr::distinct()

        # Create an indicator column for mapped lines. This join works because `ldf` has one row per `orgline`.
        ldf <- ldf %>%
          dplyr::left_join(
            mapped_orglines_df %>% dplyr::mutate(is_mapped = TRUE),
            by = c("script_num", "orgline")
          )
      } else {
        ldf$is_mapped <- FALSE
      }

      # Keep runs for lines that are regressions OR are in a map.
      # is_reg can be NA -> is.true handles this.
      # is_mapped will be NA for non-matches -> is.true handles this.
      # This works because both `runs` and `is_mapped` are attached only to the starting `orgline` of a command.
      keep_runs <- is.true(ldf$is_reg) | is.true(ldf$is_mapped)
      ldf$runs[!keep_runs] <- list(NULL)

      # Clean up the temporary column
      if ("is_mapped" %in% names(ldf)) {
        ldf <- ldf %>% dplyr::select(-.data$is_mapped)
      }
    }
  }

  # --- HTML Generation (Vectorized) ---
  script_tabs_content <- lapply(split(ldf, ldf$script_num), function(df) {
    script_num_val <- df$script_num[1]
    has_run <- !sapply(df$runs, is.null)

    line_class <- ifelse(has_run,
      sapply(df$runs, function(r) {
        if (is.null(r) || nrow(r) == 0) return("norun-line")
        cls <- if (any(isTRUE(r$errcode != 0))) "err-line" else "noerr-line"
        if (any(isTRUE(r$missing_data))) cls <- "mida-line"
        cls
      }),
      "norun-line"
    )
    line_class[is.true(df$is_reg)] <- paste(line_class[is.true(df$is_reg)], "reg-cmd")

    title <- ifelse(has_run,
      sapply(df$runs, function(r) {
        if (is.null(r) || nrow(r) == 0) return("NA")
        t <- paste0("runid: ", paste(r$runid, collapse=", "))
        if (any(r$missing_data)) t <- paste(t, " missing data")
        t
      }),
      "NA"
    )

    log_divs <- ifelse(has_run, sapply(1:nrow(df), function(i) {
        paste0('<div class="collapse" id="loginfo-', df$orgline[i], '-', script_num_val, '">', rr_make_log_html(df$runs[[i]]), '</div>')
    }), "")

    button_tds <- ifelse(has_run, paste0('<td><a class="btn btn-xs" role="button" data-toggle="collapse" href="#loginfo-', df$orgline, '-', script_num_val, '" aria-expanded="false">▼</a></td>'), "<td></td>")

    code_tags <- paste0('<code id="L', df$orgline, '___', script_num_val, '" class="', line_class, '" title="', htmltools::htmlEscape(title), '">', htmltools::htmlEscape(df$text_lines), '</code>')

    rows_html <- paste0(
      '<tr>',
        button_tds,
        '<td class="code-line-td">', df$orgline, '</td>',
        '<td><pre class="do-pre">', code_tags, '</pre>', log_divs, '</td>',
      '</tr>'
    )

    toggle_btn <- paste0('<tr><td colspan="3"><button class="toogle-all-results btn btn-xs" title="Show or hide all results" onclick="$(\'#dotab_', script_num_val, ' .collapse\').collapse(\'toggle\');">▼</button></td></tr>')

    pane_class <- if(script_num_val==1) "tab-pane active" else "tab-pane"

    paste0(
      '<div class="', pane_class, '" id="dotab_', script_num_val, '">',
        '<table class="code-tab">',
          toggle_btn,
          paste(rows_html, collapse="\n"),
        '</table>',
      '</div>'
    )
  })

  script_pills <- paste0(
    '<ul id="dotabs" class="nav nav-pills" role="tablist">',
    paste(
      mapply(function(num, file, i) {
        active_class <- if(i == 1) ' class="active"' else ''
        paste0('<li', active_class, '><a href="#dotab_', num, '" role="tab" data-toggle="tab">', file, '</a></li>')
      }, stata_source$script_num, stata_source$script_file, 1:nrow(stata_source)),
      collapse="\n"
    ),
    '</ul>'
  )
  paste0(script_pills, '<div class="tab-content">', paste(script_tabs_content, collapse="\n"), '</div>')
}

#' @describeIn rr_map_report Generate log HTML for a line, handling multiple runs.
rr_make_log_html <- function(runs_for_line) {
  if (is.null(runs_for_line) || nrow(runs_for_line) == 0) return("")

  if (nrow(runs_for_line) == 1) {
    run <- runs_for_line[1, ]
    return(paste0('<pre id="runid-', run$runid, '" class="logtxt-pre"><code class="logtxt-code">', htmltools::htmlEscape(run$logtxt), '</code></pre>'))
  }

  random_id <- function() paste0(sample(c(letters, LETTERS), 12, replace = TRUE), collapse = "")

  tabset_id <- paste0("tabset_", random_id())
  tab_ids <- replicate(nrow(runs_for_line), paste0("tab_", random_id()))

  tab_pills <- paste0(
    '<ul id="', tabset_id, '" class="nav nav-tabs small-tab-ul" role="tablist">',
    paste(
      sapply(1:nrow(runs_for_line), function(i) {
        active_class <- if (i == 1) ' class="active"' else ''
        paste0('<li', active_class, '><a href="#', tab_ids[i], '" role="tab" data-toggle="tab">Run ', i, '</a></li>')
      }),
      collapse = "\n"
    ),
    '</ul>'
  )

  tab_content <- paste0(
    '<div class="tab-content">',
    paste(
      sapply(1:nrow(runs_for_line), function(i) {
        run <- runs_for_line[i, ]
        pane_class <- if (i == 1) "tab-pane active" else "tab-pane"
        paste0(
          '<div class="', pane_class, '" id="', tab_ids[i], '">',
            '<pre id="runid-', run$runid, '" class="logtxt-pre"><code class="logtxt-code">', htmltools::htmlEscape(run$logtxt), '</code></pre>',
          '</div>'
        )
      }),
      collapse="\n"
    ),
    '</div>'
  )
  paste0(tab_pills, tab_content)
}


#' @describeIn rr_map_report Generate HTML for the table display panel.
rr_make_tab_panel_html <- function(tab_main) {
  tab_pills <- paste0(
    '<ul id="tabtabs" class="nav nav-pills" role="tablist">',
    paste(
      sapply(1:nrow(tab_main), function(i) {
        row <- tab_main[i,]
        active_class <- if(i == 1) ' class="active"' else ''
        paste0('<li', active_class, '><a href="#tabtab', row$tabid, '" role="tab" data-toggle="tab">Tab ', row$tabid, '</a></li>')
      }),
      collapse = "\n"
    ),
    '</ul>'
  )

  tab_content <- paste0(
    '<div class="tab-content">',
    paste(
      sapply(1:nrow(tab_main), function(i) {
        row <- tab_main[i,]
        active_class <- if(i == 1) "tab-pane active" else "tab-pane"
        paste0(
          '<div class="', active_class, '" id="tabtab', row$tabid, '">',
            '<div class="art-tab-div">',
              '<h5>', htmltools::htmlEscape(row$tabtitle), '</h5>',
              row$tabhtml,
            '</div>',
          '</div>'
        )
      }),
      collapse="\n"
    ),
    '</div>'
  )
  paste0(tab_pills, tab_content)
}

#' @describeIn rr_map_report Generate HTML for the top control bar.
rr_make_controls_html <- function(all_map_types) {
  map_type_names <- names(all_map_types)
  if (length(map_type_names) == 0) return("")

  type_options <- paste0('<option value="', map_type_names, '">', map_type_names, '</option>', collapse = "\n")

  # The version selector is populated by JavaScript, so it's initially empty.
  paste0(
    '<div class="controls-div form-inline">',
      '<div class="form-group">',
        '<label for="map_type_selector">Map Type:</label>',
        '<select id="map_type_selector" class="form-control input-sm">', type_options, '</select>',
      '</div>',
      '<div class="form-group">',
        '<label for="version_selector">Map Version:</label>',
        '<select id="version_selector" class="form-control input-sm"></select>',
      '</div>',
    '</div>'
  )
}

#' @describeIn rr_map_report Copy package assets to the report directory.
rr_copy_pkg_assets <- function(output_dir) {
  pkg_www_dir <- system.file("www", package = "repboxReport")
  if (pkg_www_dir == "") {
    warning("Could not find 'inst/www' directory in repboxReport package. Report assets will be missing.")
    return()
  }

  shared_dir <- file.path(output_dir, "shared")
  if (!dir.exists(shared_dir)) dir.create(shared_dir, recursive = TRUE)

  files_to_copy <- list.files(pkg_www_dir, recursive = TRUE, full.names = TRUE)

  if (length(files_to_copy) > 0) {
    file.copy(files_to_copy, shared_dir, recursive = TRUE, overwrite = TRUE)
  } else {
     warning("No assets found in 'inst/www' to copy.")
  }
}
