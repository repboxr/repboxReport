# FILE: report_map.R

example = function() {
  # The project_dir needs to be set to a valid repbox project
  project_dir = "/home/rstudio/repbox/projects_gha_new/aejapp_10_4_6"
  # Generate report with default options (embedded data)
  opts = rr_map_report_opts(embed_data = FALSE)
  rep_file = rr_map_report(project_dir,opts = opts)
  browseURL(rep_file)
  rstudioapi::filesPaneNavigate(rep_file)

  # Example with external JSON files
  # This report will need to be viewed via a web server.
  opts <- rr_map_report_opts(embed_data = FALSE)
  opts$output_for <- "all"
  output_dir_ext = file.path(project_dir, "reports_external")
  rr_map_report(project_dir, opts = opts, output_dir = output_dir_ext, output_file = "map_report_full_logs.html")
  # To view, you would run this in the R console:
  # servr::httd(output_dir_ext)

  rstudioapi::filesPaneNavigate(project_dir)
}

#' This function provides a list of default settings that can be passed to `rr_map_report`.
#'
#' **Options:**
#' * `output_for`: Determines for which commands the log output is shown.
#'   - `"reg"`: Show output only for regression commands (`is_reg=TRUE`).
#'   - `"reg_and_map"`: (Default) Show output for all regression commands and for all other commands that are part of a map.
#'   - `"all"`: Show output for all executed commands.
#'   - `"none"`: Do not show any log output.
#' * `map_prod_ids`: A character vector of map product IDs to load and display in the report. The user can switch between these map types in the UI.
#' * `embed_data`: A logical value. If `TRUE` (default), all map data is embedded into a single self-contained HTML file. If `FALSE`, map data is written to external JSON files, which makes the initial report load faster but requires a web server for viewing.
#' * `show_wrong_number_report`: A logical value or `NA`. If `TRUE`, shows the "Discrepancies Found" report based on `wrong_number_cases` from the map itself. If `FALSE`, this report is hidden. If `NA` (default), the report is hidden if a `rme.Rds` evaluation file is found for the document type, otherwise it is shown. This allows the more comprehensive evaluation report to supersede the basic one.
#'
#' @return A list of default options.
#' @export
rr_map_report_opts <- function(output_for = c("all", "reg", "reg_and_map", "none")[3],
                             map_prod_ids = c("map_reg_run", "map_inv_reg_run", "map_reg_static")[1],
                             embed_data = TRUE,
                             show_wrong_number_report = NA) {
  as.list(environment())
}


#' Creates an interactive HTML report to visualize maps
#'
#' This function generates a self-contained HTML report that visualizes the
#' maps between Stata do-files and regression tables. The report features
#' static color-coding for regression cells and interactive highlighting.
#'
#' @param project_dir The root directory of the project.
#' @param output_dir Directory for the report. Defaults to 'reports' in project_dir.
#' @param output_file The name of the HTML report file.
#' @param doc_type The document type (e.g., "art", "app1").
#' @param opts A list of options, typically generated by `rr_map_report_opts()`.
#' @return The path to the generated HTML report file.
#' @export
rr_map_report <- function(project_dir,
                          output_dir = file.path(project_dir, "reports"),
                          output_file = "map_report.html",
                          doc_type = "art",
                          opts = NULL) {
  restore.point("rr_map_report")
  # --- 0. Check dependencies & Options ---
  pkgs <- c("dplyr", "tidyr", "stringi", "htmltools", "jsonlite", "purrr", "randtoolbox")
  for (pkg in pkgs) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      stop(paste("Please install the '", pkg, "' package."), call. = FALSE)
    }
  }

  if (is.null(opts)) {
    opts <- rr_map_report_opts()
  }

  # Decide on show_wrong_number_report if it's NA
  rme_file_for_check <- file.path(project_dir, "fp", paste0("eval_", doc_type), "rme.Rds")
  if (is.na(opts$show_wrong_number_report)) {
      opts$show_wrong_number_report <- !file.exists(rme_file_for_check)
  }

  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  # --- 1. Setup asset paths ---
  assets_dir <- file.path(output_dir, "shared")
  if (!dir.exists(assets_dir)) {
    dir.create(assets_dir, recursive = TRUE)
  }

  # --- 2. Load data ---
  cat("\nLoading data...")
  parcels <- repboxDB::repdb_load_parcels(project_dir, c("stata_source", "stata_run_cmd", "stata_run_log", "stata_cmd"))

  fp_dir <- file.path(project_dir, "fp", paste0("prod_", doc_type))
  tab_main_info <- rai_pick_tab_ver(fp_dir, "tab_main")
  if(nrow(tab_main_info) == 0) {
      stop("Could not find a suitable 'tab_main' product for doc_type '", doc_type, "'")
  }
  tab_main <- fp_load_prod_df(tab_main_info$ver_dir)

  cat("\nLoading maps...")
  all_map_types <- list()
  prod_id = "map_reg_run"
  for (prod_id in opts$map_prod_ids) {
    map_list <- rr_load_all_map_versions(project_dir, doc_type, prod_id = prod_id)
    if (length(map_list) > 0) {
      all_map_types[[prod_id]] <- map_list
    }
  }
  if (length(all_map_types) == 0) {
    warning("No map versions found for any prod_id in opts$map_prod_ids. The report will be generated without interactive links.")
  }

  # Standardize reg_ind across all map types
  if (length(all_map_types) > 0) {
      cat("\nStandardizing regression indices...")
      # source("R/standardize_reg_ind.R") # This line would be used to load the function
      all_map_types <- rr_standardize_reg_ind(all_map_types)
  }


  # --- 3. Generate HTML & JS components ---
  cat("\nGenerating HTML components...")

  # Pre-compute conflict information for tooltips.
  # A conflict exists if a cell_id maps to different script/line combinations
  # across different map versions, or if it has a wrong_number_case.
  cell_conflict_data <- {
    all_maps_flat <- unlist(all_map_types, recursive = FALSE)
    all_maps_flat_df <- purrr::map_dfr(all_maps_flat, ~.x, .id = "map_version_id")

    # 1. Mapping conflicts
    mapping_conflict_msgs <- list()
    if (length(all_maps_flat) > 1 && nrow(all_maps_flat_df) > 0) {
      conflict_df <- all_maps_flat_df %>%
        rr_robust_script_num_join(parcels$stata_source$script_source) %>%
        dplyr::filter(!is.na(cell_ids), cell_ids != "", !is.na(script_num), !is.na(code_line)) %>%
        dplyr::select(map_version_id, script_num, code_line, cell_ids) %>%
        dplyr::mutate(cell_id = strsplit(as.character(cell_ids), ",")) %>%
        tidyr::unnest(cell_id) %>%
        dplyr::mutate(cell_id = trimws(cell_id)) %>%
        dplyr::filter(cell_id != "") %>%
        dplyr::select(map_version_id, cell_id, script_num, code_line) %>%
        dplyr::distinct()

      if (nrow(conflict_df) > 0) {
          conflict_summary <- conflict_df %>%
            dplyr::group_by(cell_id) %>%
            dplyr::mutate(target_key = paste(script_num, code_line, sep = ":")) %>%
            dplyr::summarise(
              num_unique_targets = dplyr::n_distinct(target_key),
              conflict_info = if (dplyr::n_distinct(target_key) > 1) {
                list(dplyr::tibble(map_version_id = map_version_id, script_num = script_num, code_line = code_line))
              } else {
                list(NULL)
              },
              .groups = "drop"
            ) %>%
            dplyr::filter(num_unique_targets > 1)

          if (nrow(conflict_summary) > 0) {
            mapping_conflict_msgs <- setNames(
              lapply(conflict_summary$conflict_info, function(info_df) {
                details <- info_df %>%
                  dplyr::distinct(map_version_id, script_num, code_line) %>%
                  dplyr::mutate(msg = paste0(map_version_id, " -> S", script_num, " L", code_line)) %>%
                  dplyr::pull(msg)
                paste0("Note: Mapped differently in other versions:\n - ", paste(details, collapse="\n - "))
              }),
              conflict_summary$cell_id
            )
          }
      }
    }

    # 2. Wrong number conflicts
    wrong_num_msgs <- list()
    if (isTRUE(opts$show_wrong_number_report) && "wrong_number_cases" %in% names(all_maps_flat_df) && nrow(all_maps_flat_df) > 0) {
        wnc_df <- all_maps_flat_df %>%
            dplyr::select(map_version_id, wrong_number_cases) %>%
            dplyr::filter(!sapply(wrong_number_cases, function(x) is.null(x) || NROW(x) == 0))

        if (nrow(wnc_df) > 0) {
            wrong_num_conflict_df <- wnc_df %>%
                tidyr::unnest(cols = wrong_number_cases) %>%
                dplyr::select(map_version_id, cell_id) %>%
                dplyr::distinct() %>%
                dplyr::filter(!is.na(cell_id)) %>%
                dplyr::group_by(cell_id) %>%
                dplyr::summarise(versions = paste(sort(unique(map_version_id)), collapse=", "), .groups="drop")

            if (nrow(wrong_num_conflict_df) > 0) {
                wrong_num_msgs <- setNames(
                    paste0("Note: Has wrong number discrepancy in version(s): ", wrong_num_conflict_df$versions),
                    wrong_num_conflict_df$cell_id
                )
            }
        }
    }

    # 3. Combine messages
    all_conflict_cells <- unique(c(names(mapping_conflict_msgs), names(wrong_num_msgs)))
    if (length(all_conflict_cells) > 0) {
        li = lapply(all_conflict_cells, function(cid) {
          restore.point("ssfk")
          msg1 = msg2 = ""
          if (cid %in% names(mapping_conflict_msgs)) {
            msg1 <- mapping_conflict_msgs[[cid]]
          }
          if (cid %in% names(wrong_num_msgs)) {
            msg2 <- wrong_num_msgs[[cid]]
          }
          # Filter NULLs and join with newline
          paste(c(msg1, msg2)[!sapply(c(msg1, msg2), is.null)], collapse="\n")
        })
        li = setNames(li,all_conflict_cells)
    } else {
        li =list()
    }
    li
  }
  js_conflict_data <- jsonlite::toJSON(cell_conflict_data, auto_unbox = TRUE)


  # Generate color map for consistent colors across all loaded maps
  all_map_dfs <- unlist(all_map_types, recursive = FALSE)
  all_reg_inds <- unique(unlist(lapply(all_map_dfs, function(df) if("reg_ind" %in% names(df)) unique(df$reg_ind) else NULL)))
  all_reg_inds <- stats::na.omit(all_reg_inds)
  reg_color_map <- rr_make_distinct_colors(length(all_reg_inds))
  names(reg_color_map) <- all_reg_inds



  # Add a script_file column for easier access
  parcels$stata_source$script_source$script_file <- basename(parcels$stata_source$script_source$file_path)

  do_panel_html <- rr_make_do_panel_html(
    stata_source = parcels$stata_source$script_source,
    stata_cmd = parcels$stata_cmd$stata_cmd,
    stata_run_cmd = parcels$stata_run_cmd$stata_run_cmd,
    stata_run_log = parcels$stata_run_log$stata_run_log,
    opts = opts,
    all_map_types = all_map_types
  )

  tab_panel_html <- rr_make_tab_panel_html(tab_main)
  controls_html <- rr_make_controls_html(all_map_types)

  # --- 4. Write JS and CSS assets ---
  cat("\nWriting JS and CSS assets...")
  rr_copy_pkg_assets(output_dir)

  # --- 5. Generate JS data and Assemble final HTML report ---

  # Conditionally generate map data (embedded vs. external)
  js_maps_data <- "{}"
  js_manifest_data <- "{}"

  if (isTRUE(opts$embed_data)) {
    cat("\nGenerating and embedding map data...")
    processed_types <- purrr::map(all_map_types, function(map_list_for_type) {
        purrr::map(map_list_for_type, function(map_df) {
            rr_process_single_map_for_js(map_df, reg_color_map, parcels$stata_source$script_source)
        })
    })
    js_maps_data <- jsonlite::toJSON(processed_types, auto_unbox = TRUE, null = "null", na = "null")
  } else {
    cat("\nGenerating external JSON files for map data...")
    maps_data_dir <- file.path(output_dir, "maps_data")
    if (!dir.exists(maps_data_dir)) dir.create(maps_data_dir, recursive = TRUE)

    manifest <- list()
    for (map_type in names(all_map_types)) {
        manifest[[map_type]] <- list()
        for (version_id in names(all_map_types[[map_type]])) {
            map_df <- all_map_types[[map_type]][[version_id]]
            processed_map_list <- rr_process_single_map_for_js(map_df, reg_color_map, parcels$stata_source$script_source)
            json_content <- jsonlite::toJSON(processed_map_list, auto_unbox = TRUE, null = "null", na = "null")

            file_name <- paste0(map_type, "_", version_id, ".json")
            file_path <- file.path(maps_data_dir, file_name)
            relative_path <- file.path("maps_data", file_name)

            writeLines(json_content, file_path)
            manifest[[map_type]][[version_id]] <- relative_path
        }
    }
    js_manifest_data <- jsonlite::toJSON(manifest, auto_unbox = TRUE)
    cat("\n\nExternal JSONs generated. Note: This report must now be viewed via a web server.")
    cat("\nYou can start one from R with: servr::httd('", normalizePath(output_dir, mustWork=FALSE), "')")
  }

  # --- 5b. Process and generate evaluation data from rme.Rds ---
  js_evals_data <- "{}"
  js_eval_manifest_data <- "{}"
  rme_file <- file.path(project_dir, "fp", paste0("eval_", doc_type), "rme.Rds")

  processed_eval_data <- NULL
  if (file.exists(rme_file)) {
      cat("\nLoading and processing evaluation data from rme.Rds...")
      tryCatch({
          rme <- readRDS(rme_file)
          processed_eval_data <- rr_process_eval_data(rme, all_map_types, parcels$stata_source$script_source)
          if (!is.null(processed_eval_data) && length(processed_eval_data) > 0) {
            cat("\nSuccessfully processed evaluation data.")
          } else {
            cat("\nEvaluation data found, but no applicable issues to report after processing.")
          }
      }, error = function(e) {
          warning("Could not load or process rme.Rds: ", e$message)
      })
    } else {
      cat("\nNo evaluation data file (rme.Rds) found, skipping.")
  }

  if (!is.null(processed_eval_data)) {
      if (isTRUE(opts$embed_data)) {
          js_evals_data <- jsonlite::toJSON(processed_eval_data, auto_unbox = TRUE, null = "null", na = "null")
      } else {
          eval_data_dir <- file.path(output_dir, "eval_data")
          if (!dir.exists(eval_data_dir)) dir.create(eval_data_dir, recursive = TRUE)

          manifest <- list()
          for (version_id in names(processed_eval_data)) {
              json_content <- jsonlite::toJSON(processed_eval_data[[version_id]], auto_unbox = TRUE, null = "null", na = "null")

              file_name <- paste0("eval_", version_id, ".json")
              file_path <- file.path(eval_data_dir, file_name)
              relative_path <- file.path("eval_data", file_name)

              writeLines(json_content, file_path)
              manifest[[version_id]] <- relative_path
          }
          js_eval_manifest_data <- jsonlite::toJSON(manifest, auto_unbox = TRUE)
      }
  }


  cat("\nAssembling final HTML report...")
  html_content <- htmltools::tagList(
    htmltools::tags$head(
      htmltools::tags$meta(charset = "UTF-8"),
      htmltools::tags$meta(`http-equiv` = "X-UA-Compatible", content = "IE=edge"),
      htmltools::tags$meta(name="viewport", content="width=device-width, initial-scale=1"),
      htmltools::tags$title(paste("map Report:", basename(project_dir))),
      htmltools::tags$link(href = "shared/bootstrap.min.css", rel = "stylesheet"),
      htmltools::tags$link(href = "shared/repbox.css", rel = "stylesheet")
    ),
    htmltools::tags$body(
      htmltools::tags$div(class = "container-fluid",
        htmltools::HTML(controls_html),
        htmltools::tags$div(class = "row", style = "height: 95vh;",
          htmltools::tags$div(id = "do-col-div", class = "col-sm-7",
            htmltools::HTML(do_panel_html)
          ),
          htmltools::tags$div(id = "tabs-col-div", class = "col-sm-5",
            htmltools::HTML(tab_panel_html)
          )
        )
      ),
      htmltools::tags$script(src = "shared/jquery.min.js"),
      htmltools::tags$script(src = "shared/bootstrap.min.js"),
      htmltools::tags$script(htmltools::HTML(paste0("var data_is_embedded = ", tolower(isTRUE(opts$embed_data)), ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var show_wrong_number_report_opt = ", tolower(isTRUE(opts$show_wrong_number_report)), ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var all_maps = ", js_maps_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var report_manifest = ", js_manifest_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var cell_conflict_data = ", js_conflict_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var all_evals = ", js_evals_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var eval_manifest = ", js_eval_manifest_data, ";"))),
      htmltools::tags$script(src = "shared/report_map.js")
    )
  )

  report_path <- file.path(output_dir, output_file)
  htmltools::save_html(html_content, file = report_path)

  message(paste("\nReport generated successfully at:", report_path))
  return(invisible(report_path))
}


# --- Helper Functions ---

#' Process rme$evals data for the report
#' @param rme The loaded rme.Rds object
#' @param all_map_types The loaded map data, used to resolve runids to code locations
#' @param stata_source The stata_source parcel, used for robust script_num joins
#' @return A nested list structured for JSON output
#' @noRd
rr_process_eval_data <- function(rme, all_map_types, stata_source) {
    restore.point("rr_process_eval_data")
    if (is.null(rme) || is.null(rme$evals)) return(NULL)

    # Descriptions for each test type, to be shown in the UI
    long_descriptions <- list(
        runids_differ = "Discrepancy Across Map Versions: Identifies cells mapped to different regression `runid`s by different AI versions, indicating areas of uncertainty.",
        invalid_runids = "Invalid `runid` Mapping: Flags mappings that point to a `runid` not found in the project's execution log. This is a critical integrity error.",
        invalid_cellids = "Invalid `cellid` Mapping: Flags mappings that reference a `cellid` that does not exist in the parsed table data. This indicates a hallucinated or malformed cell reference.",
        non_reg_cmd = "Mapping to Non-Regression Command: Identifies cells mapped to a non-regression command (e.g., `test`, `margins`). This is not necessarily an error but serves as an important note.",
        coef_se_match = "Value Mismatch between Table and Code: Compares numeric values from the table (coefficients/SEs) against the results from the mapped regression's output. Highlights discrepancies.",
        single_col_reg = "Regression Spans Multiple Columns: Flags regressions whose mapped cells span multiple columns without a clear structural reason (e.g., SEs in an adjacent column), which often indicates incorrect grouping.",
        multicol_reg_plausibility = "Implausible Multi-Column Structure: Flags multi-column regressions where every row has a value in only one column, suggesting an incorrect mapping structure.",
        overlapping_regs = "Overlapping Regression Mappings: Flags coefficient cells that have been mapped to more than one regression within the same map version, which is almost always an error.",
        consistent_vertical_structure = "Inconsistent Summary Stat Rows: Checks for consistent table structure by flagging summary statistics (e.g., 'Observations') that appear on different row numbers across columns of a single table."
    )

    # 1. Create robust lookup from runid to code location from rme$run_df (ground truth)
    runid_to_code_lookup <- NULL
    if ("run_df" %in% names(rme) && !is.null(rme$run_df)) {
        runid_to_code_lookup <- rme$run_df %>%
            dplyr::select(runid, script_num, code_line) %>%
            dplyr::filter(!is.na(runid)) %>%
            dplyr::distinct(runid, .keep_all = TRUE)
    }

    # 2. Create lookup from map info to get runid for tests that don't have it
    all_maps_flat_df <- purrr::map_dfr(unlist(all_map_types, recursive = FALSE), ~ if(!is.null(.x) && nrow(.x)>0) .x else NULL, .id = "map_version_id")
    reg_ind_to_runid_lookup <- NULL
    if (nrow(all_maps_flat_df) > 0) {
        reg_ind_to_runid_lookup <- all_maps_flat_df %>%
            dplyr::select(map_version_id, tabid, reg_ind, runid) %>%
            dplyr::filter(!is.na(reg_ind), !is.na(runid)) %>%
            dplyr::distinct()
    }

    processed_evals <- list()
    eval_tests <- rme$evals[sapply(rme$evals, function(x) !is.null(x) && NROW(x) > 0)]

    for (test_name in names(eval_tests)) {
        df <- eval_tests[[test_name]]
        df <- dplyr::ungroup(df)

        if (!"map_version" %in% names(df)) next

        df$ver_id <- df$map_version
        df <- dplyr::filter(df, !is.na(ver_id))
        if(nrow(df) == 0) next

        # Standardize runid column if it's named 'runids'
        if ("runids" %in% names(df) && !"runid" %in% names(df)) {
             df <- df %>% dplyr::rename(runid = runids)
        }

        # Ensure runid is numeric for joining
        if ("runid" %in% names(df) && !is.numeric(df$runid)) {
            df$runid <- suppressWarnings(as.numeric(as.character(df$runid)))
        }

        # If df has reg_ind but no runid, try to get runid from maps
        if (!"runid" %in% names(df) && "reg_ind" %in% names(df) && !is.null(reg_ind_to_runid_lookup)) {
            df$reg_ind <- as.integer(df$reg_ind)
            df <- dplyr::left_join(df, reg_ind_to_runid_lookup, by = c("map_version" = "map_version_id", "tabid", "reg_ind"))
        }

        # If df now has runid, join with ground truth to get code location.
        # This join will not filter out rows if runid is NA, which is what we want.
        if ("runid" %in% names(df) && !is.null(runid_to_code_lookup)) {
            df <- df %>%
                dplyr::left_join(runid_to_code_lookup, by = "runid")
        }

        # Standardize cellids: if only cellid exists, copy it to cellids for the JS
        if ("cellid" %in% names(df) && !"cellids" %in% names(df)) {
            df$cellids <- df$cellid
        }

        # Convert all columns to character to avoid JSON issues
        is_list_col <- sapply(df, is.list)
        df[!is_list_col] <- lapply(df[!is_list_col], as.character)

        df_split_ver <- split(df, df$ver_id)

        for (ver_id in names(df_split_ver)) {
            ver_df <- df_split_ver[[ver_id]]
            if (!"tabid" %in% names(ver_df)) next

            ver_df$tabid <- as.character(ver_df$tabid)
            df_split_tab <- split(ver_df, ver_df$tabid)

            for (tabid in names(df_split_tab)) {
                issue_df <- df_split_tab[[tabid]]
                cols_to_keep <- setdiff(names(issue_df), c("map_version", "ver_id", "tabid"))

                records <- purrr::transpose(issue_df[, cols_to_keep, drop = FALSE])

                processed_evals[[ver_id]][[tabid]][[test_name]] <- list(
                    description = long_descriptions[[test_name]] %||% attr(df, "descr") %||% "",
                    issues = records
                )
            }
        }
    }
    return(processed_evals)
}

#' @noRd
#' @description Robustly adds script_num to a map data frame by joining on
#' full path and then falling back to basename.
#' @param map_df The map data frame, which must contain a 'script_file' column.
#' @param stata_source The 'script_source' data frame from parcels.
#' @return The map_df with an added 'script_num' column.
rr_robust_script_num_join <- function(map_df, stata_source) {
  if (is.null(map_df) || nrow(map_df) == 0) return(map_df)
  if (!"script_file" %in% names(map_df)) return(map_df)

  # If script_num exists and is fully populated, we are done
  if ("script_num" %in% names(map_df) && !any(is.na(map_df$script_num))) return(map_df)

  # If script_num column exists but has NAs, remove it to be re-created cleanly.
  if ("script_num" %in% names(map_df)) {
    map_df <- map_df %>% dplyr::select(-script_num)
  }

  script_info <- stata_source %>%
    dplyr::select(file_path, script_num) %>%
    dplyr::distinct() %>%
    dplyr::mutate(script_basename = basename(file_path))

  # Attempt 1: Join by full path
  map_df_with_num_path <- map_df %>%
    dplyr::left_join(script_info %>% dplyr::select(file_path, script_num), by = c("script_file" = "file_path"))

  # Attempt 2: Join by basename
  script_info_basename_lookup <- script_info %>%
    dplyr::select(script_basename = script_basename, script_num_base = script_num)
  if (any(duplicated(script_info_basename_lookup$script_basename))) {
    warning("Duplicate script basenames found. Matching by basename may be ambiguous. Taking first match.")
    script_info_basename_lookup <- script_info_basename_lookup %>%
      dplyr::distinct(script_basename, .keep_all = TRUE)
  }

  map_df_with_num_base <- map_df %>%
    dplyr::left_join(script_info_basename_lookup, by = c("script_file" = "script_basename"))

  # Coalesce the results. script_num from path join takes precedence.
  map_df$script_num <- dplyr::coalesce(map_df_with_num_path$script_num, map_df_with_num_base$script_num_base)

  return(map_df)
}

# Helper to process a single map data frame into a JS-ready list structure
rr_process_single_map_for_js <- function(map_df, reg_color_map, stata_source) {
    restore.point("rr_process_single_map_for_js")
    if (is.null(map_df) || nrow(map_df) == 0) {
      # Return the new empty structure
      return(list(code_locations = list(), cell_to_code_idx = list(),
                  code_to_cells = list(), reg_info = setNames(list(), character(0)),
                  wrong_number_info = list(), cell_map = list()))
    }

    # Robustly join to get script_num
    map_df <- rr_robust_script_num_join(map_df, stata_source)

    ensure_cols <- c("runid", "script_num", "code_line", "cell_ids", "tabid", "reg_ind")
    for (col in ensure_cols) {
      if (!col %in% names(map_df)) {
        map_df[[col]] <- if (col %in% c("runid", "script_num", "code_line", "reg_ind")) NA_integer_ else NA_character_
      }
    }

    # --- NEW LOGIC FOR COMPACT CELL->CODE MAPPING (for highlighting) ---
    cell_map_df_highlight <- map_df %>%
      dplyr::filter(!is.na(cell_ids), cell_ids != "", !is.na(script_num), !is.na(code_line)) %>%
      dplyr::mutate(cell_id = strsplit(as.character(cell_ids), ",")) %>%
      tidyr::unnest(cell_id) %>%
      dplyr::mutate(cell_id = trimws(cell_id)) %>%
      dplyr::select(cell_id, runid, script_num, code_line)

    if (nrow(cell_map_df_highlight) > 0) {
        # 1. Find unique code locations and assign a 0-based index
        unique_locations <- cell_map_df_highlight %>%
          dplyr::select(runid, script_num, code_line) %>%
          dplyr::distinct() %>%
          dplyr::arrange(runid, script_num, code_line) %>%
          dplyr::mutate(location_idx = dplyr::row_number() - 1)

        # 2. Create the list of location arrays for JSON
        code_locations_list <- purrr::pmap(unique_locations[, c("runid", "script_num", "code_line")], c)

        # 3. Join back to get the index for each cell and create the named list
        cell_to_idx_df <- dplyr::left_join(cell_map_df_highlight, unique_locations, by = c("runid", "script_num", "code_line"))
        cell_to_code_idx <- setNames(as.list(cell_to_idx_df$location_idx), cell_to_idx_df$cell_id)
    } else {
        code_locations_list <- list()
        cell_to_code_idx <- list()
    }
    # --- END OF COMPACT LOGIC ---

    # --- NEW logic for cell_map for tooltips ---
    cell_map_df_tooltip <- map_df %>%
      dplyr::filter(!is.na(cell_ids), cell_ids != "", !is.na(script_num)) %>%
      dplyr::select(runid, script_num, code_line, reg_ind, cell_ids) %>%
      dplyr::mutate(cell_id = strsplit(as.character(cell_ids), ",")) %>%
      tidyr::unnest(cell_id) %>%
      dplyr::mutate(cell_id = trimws(cell_id)) %>%
      dplyr::filter(cell_id != "") %>%
      dplyr::group_by(cell_id) %>%
      dplyr::summarise(
        runid = dplyr::first(runid),
        script_num = dplyr::first(script_num),
        code_line = dplyr::first(code_line),
        reg_ind = dplyr::first(reg_ind),
        .groups = "drop"
      )

    if(nrow(cell_map_df_tooltip) > 0) {
        script_file_lookup <- stata_source %>%
            dplyr::select(script_num, file_path) %>%
            dplyr::mutate(script_file = basename(file_path)) %>%
            dplyr::select(-file_path) %>%
            dplyr::distinct()

        cell_map_df_tooltip <- cell_map_df_tooltip %>%
            dplyr::left_join(script_file_lookup, by = "script_num") %>%
            dplyr::select(-script_num)
    }


    cell_map <- if (nrow(cell_map_df_tooltip) > 0) {
      purrr::transpose(cell_map_df_tooltip[, -1]) %>%
        setNames(cell_map_df_tooltip$cell_id)
    } else {
      list()
    }


    code_map_df <- map_df %>%
      dplyr::filter(!is.na(code_line), !is.na(script_num)) %>%
      dplyr::select(script_num, code_line, tabid, cell_ids) %>%
      dplyr::distinct()
    code_to_cells <- if (nrow(code_map_df) > 0) setNames(lapply(1:nrow(code_map_df), function(i) as.list(code_map_df[i, c("tabid", "cell_ids")])), paste0("s", code_map_df$script_num, "_l", code_map_df$code_line)) else list()
    reg_info <- setNames(list(), character(0))
    if ("reg_ind" %in% names(map_df) && length(reg_color_map) > 0) {
      reg_df <- map_df %>%
        dplyr::filter(!is.na(reg_ind), !is.na(cell_ids), cell_ids != "") %>%
        dplyr::select(reg_ind, cell_ids) %>%
        dplyr::group_by(reg_ind) %>%
        dplyr::summarise(all_cell_ids = paste(unique(trimws(unlist(strsplit(cell_ids, ",")))), collapse = ","), .groups = "drop")
      if (nrow(reg_df) > 0) {
        reg_info_list <- lapply(1:nrow(reg_df), function(i) {
            reg_index_char <- as.character(reg_df$reg_ind[i])
            if (reg_index_char %in% names(reg_color_map)) list(color = reg_color_map[[reg_index_char]], cell_ids = reg_df$all_cell_ids[i]) else NULL
          })
        names(reg_info_list) <- reg_df$reg_ind
        reg_info <- reg_info_list[!sapply(reg_info_list, is.null)]
      }
    }

# --- Process wrong number cases ---
    wrong_number_info <- list()
    if ("wrong_number_cases" %in% names(map_df) && "tabid" %in% names(map_df)) {
        # The list column from JSON can contain NULLs for empty arrays. Filter these out.
        # We select the key identifiers to link the discrepancy back to its source.
        wnc_df <- map_df %>%
            dplyr::select(tabid, runid, script_num, code_line, wrong_number_cases) %>%
            dplyr::filter(!sapply(wrong_number_cases, function(x) is.null(x) || NROW(x) == 0))

        if (nrow(wnc_df) > 0) {
            wrong_number_info <- wnc_df %>%
                tidyr::unnest(cols = wrong_number_cases) %>%
                dplyr::select(
                    tabid,
                    cell_id,
                    wrong_number_in_cell,
                    number_in_stata_output,
                    runid,
                    script_num,
                    code_line
                ) %>%
                dplyr::distinct()
        }
    }

    # Return the new structure
    list(
      code_locations = code_locations_list,
      cell_to_code_idx = cell_to_code_idx,
      code_to_cells = code_to_cells,
      reg_info = reg_info,
      wrong_number_info = wrong_number_info,
      cell_map = cell_map
    )
}

#' @describeIn rr_map_report Load all available versions of a given product.
rr_load_all_map_versions <- function(project_dir, doc_type, prod_id) {
  restore.point("rr_load_all_map_versions")
  fp_dir <- file.path(project_dir, "fp", paste0("prod_", doc_type))
  prod_path <- file.path(fp_dir, prod_id)
  if (!dir.exists(prod_path)) return(list())


  ver_dirs = fp_all_ok_ver_dirs(fp_dir,prod_id = prod_id)
  if (length(ver_dirs) == 0) return(list())

  df_list <- lapply(ver_dirs, function(ver_dir) {
    df = fp_load_prod_df(ver_dir)
    df
  })

  # The old logic shortened names for v0 versions (e.g., 'model--v0' became 'model'),
  # which created an inconsistency with how evaluation data is keyed.
  # We will always use the full ver_id as the name.
  ind_df = fp_ver_dir_to_ids(ver_dirs)
  if (length(df_list) > 0 && !is.null(ind_df) && nrow(ind_df) == length(df_list)) {
    names(df_list) = ind_df$ver_id
  }

  df_list

}

# NOTE: rr_make_js_maps_data is now obsolete and has been replaced by an
# internal helper function and logic within rr_map_report.

#' @describeIn rr_map_report Generate HTML for the Stata do-file panel.
rr_make_do_panel_html <- function(stata_source, stata_cmd, stata_run_cmd, stata_run_log, opts, all_map_types = NULL) {
  restore.point("rr_make_do_panel_html")
  # --- Data Preparation ---
  run_df <- stata_run_cmd %>%
    dplyr::left_join(stata_source %>% dplyr::select(artid, file_path, script_num), by=c("artid", "file_path")) %>%
    dplyr::left_join(stata_run_log, by = c("artid", "runid", "script_num"))

  ldf <- stata_source %>%
    dplyr::mutate(text_lines = stringi::stri_split_lines(text)) %>%
    dplyr::select(script_num, file_path, text_lines) %>%
    tidyr::unnest(text_lines) %>%
    dplyr::group_by(script_num) %>%
    dplyr::mutate(orgline = dplyr::row_number()) %>%
    dplyr::ungroup()

  cmd_info <- stata_cmd %>%
    dplyr::select(file_path, line, orgline_start, orgline_end, is_reg) %>%
    dplyr::mutate(orgline = purrr::map2(orgline_start, orgline_end, seq)) %>%
    tidyr::unnest(orgline)

  ldf <- dplyr::left_join(ldf, cmd_info, by = c("file_path", "orgline"))

  run_info <- run_df %>%
    dplyr::group_by(file_path, line) %>%
    dplyr::summarise(runs = list(dplyr::tibble(runid = runid, logtxt = logtxt, errcode = errcode, missing_data = missing_data)), .groups = "drop")

  first_lines <- stata_cmd %>%
    dplyr::select(file_path, line, orgline = orgline_start) %>%
    dplyr::distinct() %>%
    dplyr::left_join(run_info, by = c("file_path", "line"))

  ldf <- dplyr::left_join(ldf, first_lines, by = c("file_path", "line", "orgline"))

  # --- Filter log output based on opts ---
  if (!is.null(opts$output_for)) {
    if (opts$output_for == "none") {
      ldf$runs <- list(NULL)
    } else if (opts$output_for == "reg") {
      # is_reg can be NA, so is.true is correct
      ldf$runs[!is.true(ldf$is_reg)] <- list(NULL)
    } else if (opts$output_for == "reg_and_map" && !is.null(all_map_types)) {
      # Get all mapped lines from all_map_types
      all_map_dfs <- unlist(all_map_types, recursive = FALSE)
      all_map_dfs <- all_map_dfs[sapply(all_map_dfs, function(df) !is.null(df) && nrow(df) > 0)]

      if (length(all_map_dfs) > 0) {

        # Use the robust join function to add script_num if missing.
        # 'stata_source' is available from the parent function's arguments.
        all_map_dfs_norm <- lapply(all_map_dfs, function(df) {
          rr_robust_script_num_join(df, stata_source)
        })

        # The map's 'code_line' corresponds to the original line number ('orgline')
        mapped_orglines_df <- dplyr::bind_rows(all_map_dfs_norm) %>%
          dplyr::filter(!is.na(script_num), !is.na(code_line)) %>%
          dplyr::select(script_num, orgline = code_line) %>%
          dplyr::distinct()

        # Create an indicator column for mapped lines. This join works because `ldf` has one row per `orgline`.
        ldf <- ldf %>%
          dplyr::left_join(
            mapped_orglines_df %>% dplyr::mutate(is_mapped = TRUE),
            by = c("script_num", "orgline")
          )
      } else {
        ldf$is_mapped <- FALSE
      }

      # Keep runs for lines that are regressions OR are in a map.
      # is_reg can be NA -> is.true handles this.
      # is_mapped will be NA for non-matches -> is.true handles this.
      # This works because both `runs` and `is_mapped` are attached only to the starting `orgline` of a command.
      keep_runs <- is.true(ldf$is_reg) | is.true(ldf$is_mapped)
      ldf$runs[!keep_runs] <- list(NULL)

      # Clean up the temporary column
      if ("is_mapped" %in% names(ldf)) {
        ldf <- ldf %>% dplyr::select(-is_mapped)
      }
    }
  }

  # --- HTML Generation (Vectorized) ---
  script_tabs_content <- lapply(split(ldf, ldf$script_num), function(df) {
    script_num_val <- df$script_num[1]
    has_run <- !sapply(df$runs, is.null)

    line_class <- ifelse(has_run,
      sapply(df$runs, function(r) {
        if (is.null(r) || nrow(r) == 0) return("norun-line")
        cls <- if (any(isTRUE(r$errcode != 0))) "err-line" else "noerr-line"
        if (any(isTRUE(r$missing_data))) cls <- "mida-line"
        cls
      }),
      "norun-line"
    )
    line_class[is.true(df$is_reg)] <- paste(line_class[is.true(df$is_reg)], "reg-cmd")

    title <- ifelse(has_run,
      sapply(df$runs, function(r) {
        if (is.null(r) || nrow(r) == 0) return("NA")
        t <- paste0("runid: ", paste(r$runid, collapse=", "))
        if (any(r$missing_data)) t <- paste(t, " missing data")
        t
      }),
      "NA"
    )

    log_divs <- ifelse(has_run, sapply(1:nrow(df), function(i) {
        paste0('<div class="collapse" id="loginfo-', df$orgline[i], '-', script_num_val, '">', rr_make_log_html(df$runs[[i]]), '</div>')
    }), "")

    button_tds <- ifelse(has_run, paste0('<td><a class="btn btn-xs" role="button" data-toggle="collapse" href="#loginfo-', df$orgline, '-', script_num_val, '" aria-expanded="false">▼</a></td>'), "<td></td>")

    code_tags <- paste0('<code id="L', df$orgline, '___', script_num_val, '" class="', line_class, '" title="', htmltools::htmlEscape(title), '">', htmltools::htmlEscape(df$text_lines), '</code>')

    rows_html <- paste0(
      '<tr>',
        button_tds,
        '<td class="code-line-td">', df$orgline, '</td>',
        '<td><pre class="do-pre">', code_tags, '</pre>', log_divs, '</td>',
      '</tr>'
    )

    toggle_btn <- paste0('<tr><td colspan="3"><button class="toogle-all-results btn btn-xs" title="Show or hide all results" onclick="$(\'#dotab_', script_num_val, ' .collapse\').collapse(\'toggle\');">▼</button></td></tr>')

    pane_class <- if(script_num_val==1) "tab-pane active" else "tab-pane"

    paste0(
      '<div class="', pane_class, '" id="dotab_', script_num_val, '">',
        '<table class="code-tab">',
          toggle_btn,
          paste(rows_html, collapse="\n"),
        '</table>',
      '</div>'
    )
  })

  script_pills <- paste0(
    '<ul id="dotabs" class="nav nav-pills" role="tablist">',
    paste(
      mapply(function(num, file, i) {
        active_class <- if(i == 1) ' class="active"' else ''
        paste0('<li', active_class, '><a href="#dotab_', num, '" role="tab" data-toggle="tab">', file, '</a></li>')
      }, stata_source$script_num, stata_source$script_file, 1:nrow(stata_source)),
      collapse="\n"
    ),
    '</ul>'
  )
  paste0(script_pills, '<div class="tab-content">', paste(script_tabs_content, collapse="\n"), '</div>')
}

#' @describeIn rr_map_report Generate log HTML for a line, handling multiple runs.
rr_make_log_html <- function(runs_for_line) {
  if (is.null(runs_for_line) || nrow(runs_for_line) == 0) return("")

  if (nrow(runs_for_line) == 1) {
    run <- runs_for_line[1, ]
    return(paste0('<pre id="runid-', run$runid, '" class="logtxt-pre"><code class="logtxt-code">', htmltools::htmlEscape(run$logtxt), '</code></pre>'))
  }

  random_id <- function() paste0(sample(c(letters, LETTERS), 12, replace = TRUE), collapse = "")

  tabset_id <- paste0("tabset_", random_id())
  tab_ids <- replicate(nrow(runs_for_line), paste0("tab_", random_id()))

  tab_pills <- paste0(
    '<ul id="', tabset_id, '" class="nav nav-tabs small-tab-ul" role="tablist">',
    paste(
      sapply(1:nrow(runs_for_line), function(i) {
        active_class <- if (i == 1) ' class="active"' else ''
        paste0('<li', active_class, '><a href="#', tab_ids[i], '" role="tab" data-toggle="tab">Run ', i, '</a></li>')
      }),
      collapse = "\n"
    ),
    '</ul>'
  )

  tab_content <- paste0(
    '<div class="tab-content">',
    paste(
      sapply(1:nrow(runs_for_line), function(i) {
        run <- runs_for_line[i, ]
        pane_class <- if (i == 1) "tab-pane active" else "tab-pane"
        paste0(
          '<div class="', pane_class, '" id="', tab_ids[i], '">',
            '<pre id="runid-', run$runid, '" class="logtxt-pre"><code class="logtxt-code">', htmltools::htmlEscape(run$logtxt), '</code></pre>',
          '</div>'
        )
      }),
      collapse="\n"
    ),
    '</div>'
  )
  paste0(tab_pills, tab_content)
}


#' @describeIn rr_map_report Generate HTML for the table display panel.
rr_make_tab_panel_html <- function(tab_main) {
  tab_pills <- paste0(
    '<ul id="tabtabs" class="nav nav-pills" role="tablist">',
    paste(
      sapply(1:nrow(tab_main), function(i) {
        row <- tab_main[i,]
        active_class <- if(i == 1) ' class="active"' else ''
        paste0('<li', active_class, '><a href="#tabtab', row$tabid, '" role="tab" data-toggle="tab">Tab ', row$tabid, '</a></li>')
      }),
      collapse = "\n"
    ),
    '</ul>'
  )

  tab_content <- paste0(
    '<div class="tab-content">',
    paste(
      sapply(1:nrow(tab_main), function(i) {
        row <- tab_main[i,]
        active_class <- if(i == 1) "tab-pane active" else "tab-pane"
        paste0(
          '<div class="', active_class, '" id="tabtab', row$tabid, '">',
            '<div class="art-tab-div">',
              '<h5>', htmltools::htmlEscape(row$tabtitle), '</h5>',
              row$tabhtml,
            '</div>',
          '</div>'
        )
      }),
      collapse="\n"
    ),
    '</div>'
  )
  paste0(tab_pills, tab_content)
}

#' @describeIn rr_map_report Generate HTML for the top control bar.
rr_make_controls_html <- function(all_map_types) {
  map_type_names <- names(all_map_types)
  if (length(map_type_names) == 0) return("")

  type_options <- paste0('<option value="', map_type_names, '">', map_type_names, '</option>', collapse = "\n")

  # The version selector is populated by JavaScript, so it's initially empty.
  paste0(
    '<div class="controls-div form-inline">',
      '<div class="form-group">',
        '<label for="map_type_selector">Map Type:</label>',
        '<select id="map_type_selector" class="form-control input-sm">', type_options, '</select>',
      '</div>',
      '<div class="form-group">',
        '<label for="version_selector">Map Version:</label>',
        '<select id="version_selector" class="form-control input-sm"></select>',
      '</div>',
    '</div>'
  )
}

#' @describeIn rr_map_report Copy package assets to the report directory.
rr_copy_pkg_assets <- function(output_dir) {
  pkg_www_dir <- system.file("www", package = "repboxReport")
  if (pkg_www_dir == "") {
    warning("Could not find 'inst/www' directory in repboxReport package. Report assets will be missing.")
    return()
  }

  shared_dir <- file.path(output_dir, "shared")
  if (!dir.exists(shared_dir)) dir.create(shared_dir, recursive = TRUE)

  files_to_copy <- list.files(pkg_www_dir, recursive = TRUE, full.names = TRUE)

  if (length(files_to_copy) > 0) {
    file.copy(files_to_copy, shared_dir, recursive = TRUE, overwrite = TRUE)
  } else {
     warning("No assets found in 'inst/www' to copy.")
  }
}
