# FILE: report_map.R

example = function() {
  library(repboxReport)
  # The project_dir needs to be set to a valid repbox project
  project_dir = "/home/rstudio/repbox/projects_gha_new/aejapp_10_4_6"
  project_dir = "/home/rstudio/repbox/projects_gha_new/aejapp_10_4_6"

  options(warn=2)
  # Generate report with default options (embedded data)
  opts = rr_map_report_opts(embed_data = FALSE)
  rep_file = rr_map_report(project_dir,opts = opts)
  browseURL(rep_file)
  rstudioapi::filesPaneNavigate(rep_file)

  rstudioapi::filesPaneNavigate(project_dir)


  # Example with external JSON files
  # This report will need to be viewed via a web server.
  opts <- rr_map_report_opts(embed_data = FALSE)
  opts$output_for <- "all"
  output_dir_ext = file.path(project_dir, "reports_external")
  rr_map_report(project_dir, opts = opts, output_dir = output_dir_ext, output_file = "map_report_full_logs.html")
  # To view, you would run this in the R console:
  # servr::httd(output_dir_ext)

  rstudioapi::filesPaneNavigate(project_dir)
}

#' This function provides a list of default settings that can be passed to `rr_map_report`.
#'
#' **Options:**
#' * `output_for`: Determines for which commands the log output is shown.
#'   - `"reg"`: Show output only for regression commands (`is_reg=TRUE`).
#'   - `"reg_and_map"`: (Default) Show output for all regression commands and for all other commands that are part of a map.
#'   - `"all"`: Show output for all executed commands.
#'   - `"none"`: Do not show any log output.
#' * `map_prod_ids`: A character vector of map product IDs to load and display in the report. The user can switch between these map types in the UI.
#' * `embed_data`: A logical value. If `TRUE` (default), all map data is embedded into a single self-contained HTML file. If `FALSE`, map data is written to external JSON files, which makes the initial report load faster but requires a web server for viewing.
#' * `show_wrong_number_report`: A logical value or `NA`. If `TRUE`, shows the "Discrepancies Found" report based on `wrong_number_cases` from the map itself. If `FALSE`, this report is hidden. If `NA` (default), the report is hidden if a `rme.Rds` evaluation file is found for the document type, otherwise it is shown. This allows the more comprehensive evaluation report to supersede the basic one.
#' * `only_tests`: An optional character vector of evaluation test names (e.g., `c("coef_se_match", "invalid_runids")`). If provided, only these tests will be included in the evaluation report.
#' * `ignore_tests`: An optional character vector of evaluation test names to exclude from the report.
#' * `test_order`: An optional character vector specifying the desired order of tests in the report. Tests included in this vector will appear first, in the specified order. Any remaining tests will be appended alphabetically.
#'
#' @return A list of default options.
#' @export
rr_map_report_opts <- function(output_for = c("all", "reg", "reg_and_map", "none")[3],map_prod_ids = c("map_reg_run", "map_inv_reg_run", "map_reg_static")[1], embed_data = TRUE,show_wrong_number_report = NA, only_tests = NULL,ignore_tests = c("non_reg_cmd"), test_order = NULL) {
  as.list(environment())
}


#' Creates an interactive HTML report to visualize maps
#'
#' This function generates a self-contained HTML report that visualizes the
#' maps between Stata do-files and regression tables. The report features
#' static color-coding for regression cells and interactive highlighting.
#'
#' @param project_dir The root directory of the project.
#' @param output_dir Directory for the report. Defaults to 'reports' in project_dir.
#' @param output_file The name of the HTML report file.
#' @param doc_type The document type (e.g., "art", "app1").
#' @param opts A list of options, typically generated by `rr_map_report_opts()`.
#' @return The path to the generated HTML report file.
#' @export
rr_map_report <- function(project_dir,
                          output_dir = file.path(project_dir, "reports"),
                          output_file = "map_report.html",
                          doc_type = "art",
                          opts = rr_map_report_opts()) {
  restore.point("rr_map_report")
  # --- 0. Check dependencies & Options ---
  pkgs <- c("dplyr", "tidyr", "stringi", "htmltools", "jsonlite", "purrr", "randtoolbox")
  for (pkg in pkgs) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      stop(paste("Please install the '", pkg, "' package."), call. = FALSE)
    }
  }

  if (is.null(opts)) {
    opts <- rr_map_report_opts()
  }

  # Decide on show_wrong_number_report if it's NA
  rme_file_for_check <- file.path(project_dir, "fp", paste0("eval_", doc_type), "rme.Rds")
  if (is.na(opts$show_wrong_number_report)) {
      opts$show_wrong_number_report <- !file.exists(rme_file_for_check)
  }

  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  # --- 1. Setup asset paths ---
  assets_dir <- file.path(output_dir, "shared")
  if (!dir.exists(assets_dir)) {
    dir.create(assets_dir, recursive = TRUE)
  }

  # --- 2. Load data ---
  cat("\nLoading data...")
  parcels <- repboxDB::repdb_load_parcels(project_dir, c("stata_source", "stata_run_cmd", "stata_run_log", "stata_cmd"))

  fp_dir <- file.path(project_dir, "fp", paste0("prod_", doc_type))
  tab_main_info <- rai_pick_tab_ver(fp_dir, "tab_main")
  if(nrow(tab_main_info) == 0) {
      stop("Could not find a suitable 'tab_main' product for doc_type '", doc_type, "'")
  }
  tab_main <- fp_load_prod_df(tab_main_info$ver_dir)

  cat("\nLoading maps...")
  all_map_types <- list()
  prod_id = "map_reg_run"
  for (prod_id in opts$map_prod_ids) {
    map_list <- rr_load_all_map_versions(project_dir, doc_type, prod_id = prod_id)
    if (length(map_list) > 0) {
      all_map_types[[prod_id]] <- map_list
    }
  }
  if (length(all_map_types) == 0) {
    warning("No map versions found for any prod_id in opts$map_prod_ids. The report will be generated without interactive links.")
  }

  # --- 3. Generate HTML & JS components ---
  cat("\nGenerating HTML components...")

  # Pre-compute conflict information for tooltips.
  # A conflict exists if a cell_id maps to different script/line combinations
  # across different map versions, or if it has a wrong_number_case.
  cell_conflict_data <- {
    all_maps_flat <- unlist(all_map_types, recursive = FALSE)
    all_maps_flat_df <- purrr::map_dfr(all_maps_flat, ~.x, .id = "map_version_id")

    # 1. Mapping conflicts
    mapping_conflict_msgs <- list()
    if (length(all_maps_flat) > 1 && nrow(all_maps_flat_df) > 0) {
      conflict_df <- all_maps_flat_df %>%
        rr_robust_script_num_join(parcels$stata_source$script_source) %>%
        filter(!is.na(cell_ids), cell_ids != "", !is.na(script_num), !is.na(code_line)) %>%
        select(map_version_id, script_num, code_line, cell_ids) %>%
        mutate(cell_id = strsplit(as.character(cell_ids), ",")) %>%
        tidyr::unnest(cell_id) %>%
        mutate(cell_id = trimws(cell_id)) %>%
        filter(cell_id != "") %>%
        select(map_version_id, cell_id, script_num, code_line) %>%
        distinct()

      if (nrow(conflict_df) > 0) {
          conflict_summary <- conflict_df %>%
            group_by(cell_id) %>%
            mutate(target_key = paste(script_num, code_line, sep = ":")) %>%
            summarise(
              num_unique_targets = n_distinct(target_key),
              conflict_info = if (n_distinct(target_key) > 1) {
                list(tibble(map_version_id = map_version_id, script_num = script_num, code_line = code_line))
              } else {
                list(NULL)
              },
              .groups = "drop"
            ) %>%
            filter(num_unique_targets > 1)

          if (nrow(conflict_summary) > 0) {
            mapping_conflict_msgs <- setNames(
              lapply(conflict_summary$conflict_info, function(info_df) {
                details <- info_df %>%
                  distinct(map_version_id, script_num, code_line) %>%
                  mutate(msg = paste0(map_version_id, " -> S", script_num, " L", code_line)) %>%
                  pull(msg)
                paste0("Note: Mapped differently in other versions:\n - ", paste(details, collapse="\n - "))
              }),
              conflict_summary$cell_id
            )
          }
      }
    }

    # 2. Wrong number conflicts
    wrong_num_msgs <- list()
    if (isTRUE(opts$show_wrong_number_report) && "wrong_number_cases" %in% names(all_maps_flat_df) && nrow(all_maps_flat_df) > 0) {
        wnc_df <- all_maps_flat_df %>%
            select(map_version_id, wrong_number_cases) %>%
            filter(!sapply(wrong_number_cases, function(x) is.null(x) || NROW(x) == 0))

        if (nrow(wnc_df) > 0) {
            wrong_num_conflict_df <- wnc_df %>%
                tidyr::unnest(cols = wrong_number_cases) %>%
                select(map_version_id, cell_id) %>%
                distinct() %>%
                filter(!is.na(cell_id)) %>%
                group_by(cell_id) %>%
                summarise(versions = paste(sort(unique(map_version_id)), collapse=", "), .groups="drop")

            if (nrow(wrong_num_conflict_df) > 0) {
                wrong_num_msgs <- setNames(
                    paste0("Note: Has wrong number discrepancy in version(s): ", wrong_num_conflict_df$versions),
                    wrong_num_conflict_df$cell_id
                )
            }
        }
    }

    # 3. Combine messages
    all_conflict_cells <- unique(c(names(mapping_conflict_msgs), names(wrong_num_msgs)))
    if (length(all_conflict_cells) > 0) {
        li = lapply(all_conflict_cells, function(cid) {
          restore.point("ssfk")
          msg1 = msg2 = ""
          if (cid %in% names(mapping_conflict_msgs)) {
            msg1 <- mapping_conflict_msgs[[cid]]
          }
          if (cid %in% names(wrong_num_msgs)) {
            msg2 <- wrong_num_msgs[[cid]]
          }
          # Filter NULLs and join with newline
          paste(c(msg1, msg2)[!sapply(c(msg1, msg2), is.null)], collapse="\n")
        })
        li = setNames(li,all_conflict_cells)
    } else {
        li =list()
    }
    li
  }
  js_conflict_data <- jsonlite::toJSON(cell_conflict_data, auto_unbox = TRUE)


  # Generate color map for consistent colors across all loaded maps
  all_map_dfs <- unlist(all_map_types, recursive = FALSE)
  all_regids <- unique(unlist(lapply(all_map_dfs, function(df) if("regid" %in% names(df)) unique(df$regid) else NULL)))
  all_regids <- stats::na.omit(all_regids)
  reg_color_map <- rr_make_distinct_colors(length(all_regids))
  names(reg_color_map) <- all_regids



  # Add a script_file column for easier access
  parcels$stata_source$script_source$script_file <- basename(parcels$stata_source$script_source$file_path)

  do_panel_html <- rr_make_do_panel_html(
    stata_source = parcels$stata_source$script_source,
    stata_cmd = parcels$stata_cmd$stata_cmd,
    stata_run_cmd = parcels$stata_run_cmd$stata_run_cmd,
    stata_run_log = parcels$stata_run_log$stata_run_log,
    opts = opts,
    all_map_types = all_map_types
  )

  tab_panel_html <- rr_make_tab_panel_html(tab_main)
  controls_html <- rr_make_controls_html(all_map_types)

  # --- 4. Write JS and CSS assets ---
  cat("\nWriting JS and CSS assets...")
  rr_copy_pkg_assets(output_dir)

  # --- 5. Generate JS data and Assemble final HTML report ---

  # Conditionally generate map data (embedded vs. external)
  js_maps_data <- "{}"
  js_manifest_data <- "{}"

  if (isTRUE(opts$embed_data)) {
    cat("\nGenerating and embedding map data...")
    processed_types <- purrr::map(all_map_types, function(map_list_for_type) {
        purrr::map(map_list_for_type, function(map_df) {
            rr_process_single_map_for_js(map_df, reg_color_map, parcels$stata_source$script_source)
        })
    })
    js_maps_data <- jsonlite::toJSON(processed_types, auto_unbox = TRUE, null = "null", na = "null")
  } else {
    cat("\nGenerating external JSON files for map data...")
    maps_data_dir <- file.path(output_dir, "maps_data")
    if (!dir.exists(maps_data_dir)) dir.create(maps_data_dir, recursive = TRUE)

    manifest <- list()
    for (map_type in names(all_map_types)) {
        manifest[[map_type]] <- list()
        for (version_id in names(all_map_types[[map_type]])) {
            map_df <- all_map_types[[map_type]][[version_id]]
            processed_map_list <- rr_process_single_map_for_js(map_df, reg_color_map, parcels$stata_source$script_source)
            json_content <- jsonlite::toJSON(processed_map_list, auto_unbox = TRUE, null = "null", na = "null")

            file_name <- paste0(map_type, "_", version_id, ".json")
            file_path <- file.path(maps_data_dir, file_name)
            relative_path <- file.path("maps_data", file_name)

            writeLines(json_content, file_path)
            manifest[[map_type]][[version_id]] <- relative_path
        }
    }
    js_manifest_data <- jsonlite::toJSON(manifest, auto_unbox = TRUE)
    cat("\n\nExternal JSONs generated. Note: This report must now be viewed via a web server.")
    cat("\nYou can start one from R with: servr::httd('", normalizePath(output_dir, mustWork=FALSE), "')")
  }

  # --- 5b. Process and generate evaluation data from rme.Rds ---
  js_evals_data <- "{}"
  js_eval_manifest_data <- "{}"
  rme_file <- file.path(project_dir, "fp", paste0("eval_", doc_type), "rme.Rds")

  processed_eval_data <- NULL
  if (file.exists(rme_file)) {
      cat("\nLoading and processing evaluation data from rme.Rds...")
      tryCatch({
          rme <- readRDS(rme_file)
          processed_eval_data <- rr_process_eval_data(rme, all_map_types, parcels$stata_source$script_source, opts)
          if (!is.null(processed_eval_data) && length(processed_eval_data) > 0) {
            cat("\nSuccessfully processed evaluation data.")
          } else {
            cat("\nEvaluation data found, but no applicable issues to report after processing.")
          }
      }, error = function(e) {
          warning("Could not load or process rme.Rds: ", e$message)
      })
    } else {
      cat("\nNo evaluation data file (rme.Rds) found, skipping.")
  }

  if (!is.null(processed_eval_data)) {
      if (isTRUE(opts$embed_data)) {
          js_evals_data <- jsonlite::toJSON(processed_eval_data, auto_unbox = TRUE, null = "null", na = "null")
      } else {
          eval_data_dir <- file.path(output_dir, "eval_data")
          if (!dir.exists(eval_data_dir)) dir.create(eval_data_dir, recursive = TRUE)

          manifest <- list()
          for (version_id in names(processed_eval_data)) {
              json_content <- jsonlite::toJSON(processed_eval_data[[version_id]], auto_unbox = TRUE, null = "null", na = "null")

              file_name <- paste0("eval_", version_id, ".json")
              file_path <- file.path(eval_data_dir, file_name)
              relative_path <- file.path("eval_data", file_name)

              writeLines(json_content, file_path)
              manifest[[version_id]] <- relative_path
          }
          js_eval_manifest_data <- jsonlite::toJSON(manifest, auto_unbox = TRUE)
      }
  }


  cat("\nAssembling final HTML report...")
  html_content <- htmltools::tagList(
    htmltools::tags$head(
      htmltools::tags$meta(charset = "UTF-8"),
      htmltools::tags$meta(`http-equiv` = "X-UA-Compatible", content = "IE=edge"),
      htmltools::tags$meta(name="viewport", content="width=device-width, initial-scale=1"),
      htmltools::tags$title(paste("map Report:", basename(project_dir))),
      htmltools::tags$link(href = "shared/bootstrap.min.css", rel = "stylesheet"),
      htmltools::tags$link(href = "shared/repbox.css", rel = "stylesheet")
    ),
    htmltools::tags$body(
      htmltools::tags$div(class = "container-fluid",
        htmltools::HTML(controls_html),
        htmltools::tags$div(class = "row", style = "height: 95vh;",
          htmltools::tags$div(id = "do-col-div", class = "col-sm-7",
            htmltools::HTML(do_panel_html)
          ),
          htmltools::tags$div(id = "tabs-col-div", class = "col-sm-5",
            htmltools::HTML(tab_panel_html)
          )
        )
      ),
      htmltools::tags$script(src = "shared/jquery.min.js"),
      htmltools::tags$script(src = "shared/bootstrap.min.js"),
      htmltools::tags$script(htmltools::HTML(paste0("var data_is_embedded = ", tolower(isTRUE(opts$embed_data)), ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var show_wrong_number_report_opt = ", tolower(isTRUE(opts$show_wrong_number_report)), ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var all_maps = ", js_maps_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var report_manifest = ", js_manifest_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var cell_conflict_data = ", js_conflict_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var all_evals = ", js_evals_data, ";"))),
      htmltools::tags$script(htmltools::HTML(paste0("var eval_manifest = ", js_eval_manifest_data, ";"))),
      htmltools::tags$script(src = "shared/report_map.js")
    )
  )

  report_path <- file.path(output_dir, output_file)
  htmltools::save_html(html_content, file = report_path)

  message(paste("\nReport generated successfully at:", report_path))
  return(invisible(report_path))
}


# --- Helper Functions ---
#' Process rme$evals data for the report
#' @param rme The loaded rme.Rds object
#' @param all_map_types The loaded map data, used to resolve runids to code locations
#' @param stata_source The stata_source parcel, used for robust script_num joins
#' @param opts A list of options, typically from `rr_map_report_opts()`.
#' @return A nested list structured for JSON output
#' @noRd
rr_process_eval_data <- function(rme, all_map_types, stata_source, opts = list()) {
    restore.point("rr_process_eval_data")

    #rme$evals = rme$evals[!names(rme$evals) %in% ignore_evals]

    if (is.null(rme) || is.null(rme$evals)) return(NULL)



    # 1. Create robust lookup from runid to code location from rme$run_df (ground truth)
    runid_to_code_lookup <- NULL
    if ("run_df" %in% names(rme) && !is.null(rme$run_df)) {
        runid_to_code_lookup <- rme$run_df %>%
            select(runid, script_num, code_line) %>%
            filter(!is.na(runid)) %>%
            distinct(runid, .keep_all = TRUE)
    }

    # 2. Create lookup from map info to get runid for tests that don't have it
    all_maps_flat_df <- purrr::map_dfr(unlist(all_map_types, recursive = FALSE), ~ if(!is.null(.x) && nrow(.x)>0) .x else NULL, .id = "map_version_id")

  # FIX: unlist() combined with map_dfr creates a composite ID (e.g., "map_reg_run.g25f-mocr--v0").
  # We must strip the product ID prefix so the join with rme data works on just the version ID.
  restore.point("before_fix")
  if (nrow(all_maps_flat_df) > 0) {
    all_maps_flat_df$map_version_id = stringi::stri_replace_first_regex(all_maps_flat_df$map_version_id, "^[^\\.]+\\.", "")
  }

    regid_to_runid_lookup <- NULL
    if (nrow(all_maps_flat_df) > 0) {
        regid_to_runid_lookup <- all_maps_flat_df %>%
            select(map_version_id, tabid, regid, runid) %>%
            filter(!is.na(regid), !is.na(runid)) %>%
            distinct()
    }

    # 3. Filter and order tests to be processed
    eval_tests <- rme$evals[sapply(rme$evals, function(x) !is.null(x) && NROW(x) > 0)]
    if (length(eval_tests) == 0) return(NULL)

    tests_to_process <- names(eval_tests)

    if (!is.null(opts$only_tests)) {
      tests_to_process <- intersect(tests_to_process, opts$only_tests)
    }
    if (!is.null(opts$ignore_tests)) {
      tests_to_process <- setdiff(tests_to_process, opts$ignore_tests)
    }

    if (!is.null(opts$test_order)) {
        ordered_part <- intersect(opts$test_order, tests_to_process)
        remaining_part <- sort(setdiff(tests_to_process, opts$test_order))
        final_test_order <- c(ordered_part, remaining_part)
    } else {
        final_test_order <- sort(tests_to_process)
    }


    processed_evals <- list()
    for (test_name in final_test_order) {
        df <- eval_tests[[test_name]]
        df <- ungroup(df)

        if (!"map_version" %in% names(df)) next

        df$ver_id <- df$map_version
        df <- filter(df, !is.na(ver_id))
        if(nrow(df) == 0) next

        # Standardize runid column if it's named 'runids'
        if ("runids" %in% names(df) && !"runid" %in% names(df)) {
             df <- df %>% rename(runid = runids)
        }

        # Ensure runid is numeric for joining
        if ("runid" %in% names(df) && !is.numeric(df$runid)) {
            df$runid <- suppressWarnings(as.numeric(as.character(df$runid)))
        }

        # If df has regid but no runid, try to get runid from maps
        if (!"runid" %in% names(df) && "regid" %in% names(df) && !is.null(regid_to_runid_lookup)) {
            df <- left_join(df, regid_to_runid_lookup, by = c("map_version" = "map_version_id", "tabid", "regid"))
        }

        # If df now has runid, join with ground truth to get code location.
        # This join will not filter out rows if runid is NA, which is what we want.
        if ("runid" %in% names(df) && !is.null(runid_to_code_lookup)) {
            df <- df %>%
                left_join(runid_to_code_lookup, by = "runid")
        }

        # Standardize cellids: if only cellid exists, copy it to cellids for the JS
        if ("cellid" %in% names(df) && !"cellids" %in% names(df)) {
            df$cellids <- df$cellid
        }

        # Convert all columns to character to avoid JSON issues
        is_list_col <- sapply(df, is.list)
        df[!is_list_col] <- lapply(df[!is_list_col], as.character)

        df_split_ver <- split(df, df$ver_id)

        for (ver_id in names(df_split_ver)) {
            ver_df <- df_split_ver[[ver_id]]
            if (!"tabid" %in% names(ver_df)) next

            ver_df$tabid <- as.character(ver_df$tabid)
            df_split_tab <- split(ver_df, ver_df$tabid)

            for (tabid in names(df_split_tab)) {
                issue_df <- df_split_tab[[tabid]]
                cols_to_keep <- setdiff(names(issue_df), c("map_version", "ver_id", "tabid"))

                records <- purrr::transpose(issue_df[, cols_to_keep, drop = FALSE])

                description <- attr(eval_tests[[test_name]], "long_descr") %||%
                               attr(eval_tests[[test_name]], "descr") %||%
                               paste0("No description available for test: '", test_name, "'.")

                processed_evals[[ver_id]][[tabid]][[test_name]] <- list(
                    description = description,
                    issues = records
                )
            }
        }
    }
    return(processed_evals)
}
#' @noRd
#' @description Robustly adds script_num to a map data frame by joining on
#' full path and then falling back to basename.
#' @param map_df The map data frame, which must contain a 'script_file' column.
#' @param stata_source The 'script_source' data frame from parcels.
#' @return The map_df with an added 'script_num' column.
rr_robust_script_num_join <- function(map_df, stata_source) {
  if (is.null(map_df) || nrow(map_df) == 0) return(map_df)
  if (!"script_file" %in% names(map_df)) return(map_df)

  # If script_num exists and is fully populated, we are done
  if ("script_num" %in% names(map_df) && !any(is.na(map_df$script_num))) return(map_df)

  # If script_num column exists but has NAs, remove it to be re-created cleanly.
  if ("script_num" %in% names(map_df)) {
    map_df <- map_df %>% select(-script_num)
  }

  script_info <- stata_source %>%
    select(file_path, script_num) %>%
    distinct() %>%
    mutate(script_basename = basename(file_path))

  # Attempt 1: Join by full path
  map_df_with_num_path <- map_df %>%
    left_join(script_info %>% select(file_path, script_num), by = c("script_file" = "file_path"))

  # Attempt 2: Join by basename
  script_info_basename_lookup <- script_info %>%
    select(script_basename = script_basename, script_num_base = script_num)
  if (any(duplicated(script_info_basename_lookup$script_basename))) {
    warning("Duplicate script basenames found. Matching by basename may be ambiguous. Taking first match.")
    script_info_basename_lookup <- script_info_basename_lookup %>%
      distinct(script_basename, .keep_all = TRUE)
  }

  map_df_with_num_base <- map_df %>%
    left_join(script_info_basename_lookup, by = c("script_file" = "script_basename"))

  # Coalesce the results. script_num from path join takes precedence.
  map_df$script_num <- coalesce(map_df_with_num_path$script_num, map_df_with_num_base$script_num_base)

  return(map_df)
}

# Helper to process a single map data frame into a JS-ready list structure
rr_process_single_map_for_js <- function(map_df, reg_color_map, stata_source) {
    restore.point("rr_process_single_map_for_js")
    if (is.null(map_df) || nrow(map_df) == 0) {
      # Return the new empty structure
      return(list(code_locations = list(), cell_to_code_idx = list(),
                  code_to_cells = list(), reg_info = setNames(list(), character(0)),
                  wrong_number_info = list(), cell_map = list()))
    }

    # Robustly join to get script_num
    map_df <- rr_robust_script_num_join(map_df, stata_source)

    ensure_cols <- c("runid", "script_num", "code_line", "cell_ids", "tabid", "regid")
    for (col in ensure_cols) {
      if (!col %in% names(map_df)) {
        map_df[[col]] <- if (col %in% c("runid", "script_num", "code_line", "regid")) NA_integer_ else NA_character_
      }
    }

    # --- NEW LOGIC FOR COMPACT CELL->CODE MAPPING (for highlighting) ---
    cell_map_df_highlight <- map_df %>%
      filter(!is.na(cell_ids), cell_ids != "", !is.na(script_num), !is.na(code_line)) %>%
      mutate(cell_id = strsplit(as.character(cell_ids), ",")) %>%
      tidyr::unnest(cell_id) %>%
      mutate(cell_id = trimws(cell_id)) %>%
      select(cell_id, runid, script_num, code_line)

    if (nrow(cell_map_df_highlight) > 0) {
        # 1. Find unique code locations and assign a 0-based index
        unique_locations <- cell_map_df_highlight %>%
          select(runid, script_num, code_line) %>%
          distinct() %>%
          arrange(runid, script_num, code_line) %>%
          mutate(location_idx = row_number() - 1)

        # 2. Create the list of location arrays for JSON
        code_locations_list <- purrr::pmap(unique_locations[, c("runid", "script_num", "code_line")], c)

        # 3. Join back to get the index for each cell and create the named list
        cell_to_idx_df <- left_join(cell_map_df_highlight, unique_locations, by = c("runid", "script_num", "code_line"))
        cell_to_code_idx <- setNames(as.list(cell_to_idx_df$location_idx), cell_to_idx_df$cell_id)
    } else {
        code_locations_list <- list()
        cell_to_code_idx <- list()
    }
    # --- END OF COMPACT LOGIC ---

    # --- NEW logic for cell_map for tooltips ---
    cell_map_df_tooltip <- map_df %>%
      filter(!is.na(cell_ids), cell_ids != "", !is.na(script_num)) %>%
      select(runid, script_num, code_line, regid, cell_ids) %>%
      mutate(cell_id = strsplit(as.character(cell_ids), ",")) %>%
      tidyr::unnest(cell_id) %>%
      mutate(cell_id = trimws(cell_id)) %>%
      filter(cell_id != "") %>%
      group_by(cell_id) %>%
      summarise(
        runid = first(runid),
        script_num = first(script_num),
        code_line = first(code_line),
        regid = first(regid),
        .groups = "drop"
      )

    if(nrow(cell_map_df_tooltip) > 0) {
        script_file_lookup <- stata_source %>%
            select(script_num, file_path) %>%
            mutate(script_file = basename(file_path)) %>%
            select(-file_path) %>%
            distinct()

        cell_map_df_tooltip <- cell_map_df_tooltip %>%
            left_join(script_file_lookup, by = "script_num") %>%
            select(-script_num)
    }


    cell_map <- if (nrow(cell_map_df_tooltip) > 0) {
      purrr::transpose(cell_map_df_tooltip[, -1]) %>%
        setNames(cell_map_df_tooltip$cell_id)
    } else {
      list()
    }


    code_map_df <- map_df %>%
      filter(!is.na(code_line), !is.na(script_num)) %>%
      select(script_num, code_line, tabid, cell_ids) %>%
      distinct()
    code_to_cells <- if (nrow(code_map_df) > 0) setNames(lapply(1:nrow(code_map_df), function(i) as.list(code_map_df[i, c("tabid", "cell_ids")])), paste0("s", code_map_df$script_num, "_l", code_map_df$code_line)) else list()
    reg_info <- setNames(list(), character(0))
    if ("regid" %in% names(map_df) && length(reg_color_map) > 0) {
      reg_df <- map_df %>%
        filter(!is.na(regid), !is.na(cell_ids), cell_ids != "") %>%
        select(regid, cell_ids) %>%
        group_by(regid) %>%
        summarise(all_cell_ids = paste(unique(trimws(unlist(strsplit(cell_ids, ",")))), collapse = ","), .groups = "drop")
      if (nrow(reg_df) > 0) {
        reg_info_list <- lapply(1:nrow(reg_df), function(i) {
            regidex_char <- as.character(reg_df$regid[i])
            if (regidex_char %in% names(reg_color_map)) list(color = reg_color_map[[regidex_char]], cell_ids = reg_df$all_cell_ids[i]) else NULL
          })
        names(reg_info_list) <- reg_df$regid
        reg_info <- reg_info_list[!sapply(reg_info_list, is.null)]
      }
    }

# --- Process wrong number cases ---
    wrong_number_info <- list()
    if ("wrong_number_cases" %in% names(map_df) && "tabid" %in% names(map_df)) {
        # The list column from JSON can contain NULLs for empty arrays. Filter these out.
        # We select the key identifiers to link the discrepancy back to its source.
        wnc_df <- map_df %>%
            select(tabid, runid, script_num, code_line, wrong_number_cases) %>%
            filter(!sapply(wrong_number_cases, function(x) is.null(x) || NROW(x) == 0))

        if (nrow(wnc_df) > 0) {
            wrong_number_info <- wnc_df %>%
                tidyr::unnest(cols = wrong_number_cases) %>%
                select(
                    tabid,
                    cell_id,
                    wrong_number_in_cell,
                    number_in_stata_output,
                    runid,
                    script_num,
                    code_line
                ) %>%
                distinct()
        }
    }

    # Return the new structure
    list(
      code_locations = code_locations_list,
      cell_to_code_idx = cell_to_code_idx,
      code_to_cells = code_to_cells,
      reg_info = reg_info,
      wrong_number_info = wrong_number_info,
      cell_map = cell_map
    )
}

#' @describeIn rr_map_report Load all available versions of a given product.
rr_load_all_map_versions <- function(project_dir, doc_type, prod_id) {
  restore.point("rr_load_all_map_versions")
  fp_dir <- file.path(project_dir, "fp", paste0("prod_", doc_type))
  prod_path <- file.path(fp_dir, prod_id)
  if (!dir.exists(prod_path)) return(list())


  ver_dirs = fp_all_ok_ver_dirs(fp_dir,prod_id = prod_id)
  if (length(ver_dirs) == 0) return(list())

  df_list <- lapply(ver_dirs, function(ver_dir) {
    df = fp_load_prod_df(ver_dir)
    df
  })

  # The old logic shortened names for v0 versions (e.g., 'model--v0' became 'model'),
  # which created an inconsistency with how evaluation data is keyed.
  # We will always use the full ver_id as the name.
  ind_df = fp_ver_dir_to_ids(ver_dirs)
  if (length(df_list) > 0 && !is.null(ind_df) && nrow(ind_df) == length(df_list)) {
    names(df_list) = ind_df$ver_id
  }

  df_list

}

# NOTE: rr_make_js_maps_data is now obsolete and has been replaced by an
# internal helper function and logic within rr_map_report.

#' @describeIn rr_map_report Generate HTML for the Stata do-file panel.
rr_make_do_panel_html <- function(stata_source, stata_cmd, stata_run_cmd, stata_run_log, opts, all_map_types = NULL) {
  restore.point("rr_make_do_panel_html")
  # --- Data Preparation ---
  run_df <- stata_run_cmd %>%
    left_join(stata_source %>% select(artid, file_path, script_num), by=c("artid", "file_path")) %>%
    left_join(stata_run_log, by = c("artid", "runid", "script_num"))

  ldf <- stata_source %>%
    mutate(text_lines = stringi::stri_split_lines(text)) %>%
    select(script_num, file_path, text_lines) %>%
    tidyr::unnest(text_lines) %>%
    group_by(script_num) %>%
    mutate(orgline = row_number()) %>%
    ungroup()

  cmd_info <- stata_cmd %>%
    select(file_path, line, orgline_start, orgline_end, is_reg) %>%
    mutate(orgline = purrr::map2(orgline_start, orgline_end, seq)) %>%
    tidyr::unnest(orgline)

  ldf <- left_join(ldf, cmd_info, by = c("file_path", "orgline"))

  run_info <- run_df %>%
    group_by(file_path, line) %>%
    summarise(runs = list(tibble(runid = runid, logtxt = logtxt, errcode = errcode, missing_data = missing_data)), .groups = "drop")

  first_lines <- stata_cmd %>%
    select(file_path, line, orgline = orgline_start) %>%
    distinct() %>%
    left_join(run_info, by = c("file_path", "line"))

  ldf <- left_join(ldf, first_lines, by = c("file_path", "line", "orgline"))

  # --- Filter log output based on opts ---
  if (!is.null(opts$output_for)) {
    if (opts$output_for == "none") {
      ldf$runs <- list(NULL)
    } else if (opts$output_for == "reg") {
      # is_reg can be NA, so is.true is correct
      ldf$runs[!is.true(ldf$is_reg)] <- list(NULL)
    } else if (opts$output_for == "reg_and_map" && !is.null(all_map_types)) {
      # Get all mapped lines from all_map_types
      all_map_dfs <- unlist(all_map_types, recursive = FALSE)
      all_map_dfs <- all_map_dfs[sapply(all_map_dfs, function(df) !is.null(df) && nrow(df) > 0)]

      if (length(all_map_dfs) > 0) {

        # Use the robust join function to add script_num if missing.
        # 'stata_source' is available from the parent function's arguments.
        all_map_dfs_norm <- lapply(all_map_dfs, function(df) {
          rr_robust_script_num_join(df, stata_source)
        })

        # The map's 'code_line' corresponds to the original line number ('orgline')
        mapped_orglines_df <- bind_rows(all_map_dfs_norm) %>%
          filter(!is.na(script_num), !is.na(code_line)) %>%
          select(script_num, orgline = code_line) %>%
          distinct()

        # Create an indicator column for mapped lines. This join works because `ldf` has one row per `orgline`.
        ldf <- ldf %>%
          left_join(
            mapped_orglines_df %>% mutate(is_mapped = TRUE),
            by = c("script_num", "orgline")
          )
      } else {
        ldf$is_mapped <- FALSE
      }

      # Keep runs for lines that are regressions OR are in a map.
      # is_reg can be NA -> is.true handles this.
      # is_mapped will be NA for non-matches -> is.true handles this.
      # This works because both `runs` and `is_mapped` are attached only to the starting `orgline` of a command.
      keep_runs <- is.true(ldf$is_reg) | is.true(ldf$is_mapped)
      ldf$runs[!keep_runs] <- list(NULL)

      # Clean up the temporary column
      if ("is_mapped" %in% names(ldf)) {
        ldf <- ldf %>% select(-is_mapped)
      }
    }
  }

  # --- HTML Generation (Vectorized) ---
  script_tabs_content <- lapply(split(ldf, ldf$script_num), function(df) {
    script_num_val <- df$script_num[1]
    has_run <- !sapply(df$runs, is.null)

    line_class <- ifelse(has_run,
      sapply(df$runs, function(r) {
        if (is.null(r) || nrow(r) == 0) return("norun-line")
        cls <- if (any(isTRUE(r$errcode != 0))) "err-line" else "noerr-line"
        if (any(isTRUE(r$missing_data))) cls <- "mida-line"
        cls
      }),
      "norun-line"
    )
    line_class[is.true(df$is_reg)] <- paste(line_class[is.true(df$is_reg)], "reg-cmd")

    title <- ifelse(has_run,
      sapply(df$runs, function(r) {
        if (is.null(r) || nrow(r) == 0) return("NA")
        t <- paste0("runid: ", paste(r$runid, collapse=", "))
        if (any(r$missing_data)) t <- paste(t, " missing data")
        t
      }),
      "NA"
    )

    log_divs <- ifelse(has_run, sapply(1:nrow(df), function(i) {
        paste0('<div class="collapse" id="loginfo-', df$orgline[i], '-', script_num_val, '">', rr_make_log_html(df$runs[[i]]), '</div>')
    }), "")

    button_tds <- ifelse(has_run, paste0('<td><a class="btn btn-xs" role="button" data-toggle="collapse" href="#loginfo-', df$orgline, '-', script_num_val, '" aria-expanded="false">▼</a></td>'), "<td></td>")

    code_tags <- paste0('<code id="L', df$orgline, '___', script_num_val, '" class="', line_class, '" title="', htmltools::htmlEscape(title), '">', htmltools::htmlEscape(df$text_lines), '</code>')

    rows_html <- paste0(
      '<tr>',
        button_tds,
        '<td class="code-line-td">', df$orgline, '</td>',
        '<td><pre class="do-pre">', code_tags, '</pre>', log_divs, '</td>',
      '</tr>'
    )

    toggle_btn <- paste0('<tr><td colspan="3"><button class="toogle-all-results btn btn-xs" title="Show or hide all results" onclick="$(\'#dotab_', script_num_val, ' .collapse\').collapse(\'toggle\');">▼</button></td></tr>')

    pane_class <- if(script_num_val==1) "tab-pane active" else "tab-pane"

    paste0(
      '<div class="', pane_class, '" id="dotab_', script_num_val, '">',
        '<table class="code-tab">',
          toggle_btn,
          paste(rows_html, collapse="\n"),
        '</table>',
      '</div>'
    )
  })

  script_pills <- paste0(
    '<ul id="dotabs" class="nav nav-pills" role="tablist">',
    paste(
      mapply(function(num, file, i) {
        active_class <- if(i == 1) ' class="active"' else ''
        paste0('<li', active_class, '><a href="#dotab_', num, '" role="tab" data-toggle="tab">', file, '</a></li>')
      }, stata_source$script_num, stata_source$script_file, 1:nrow(stata_source)),
      collapse="\n"
    ),
    '</ul>'
  )
  paste0(script_pills, '<div class="tab-content">', paste(script_tabs_content, collapse="\n"), '</div>')
}

#' @describeIn rr_map_report Generate log HTML for a line, handling multiple runs.
rr_make_log_html <- function(runs_for_line) {
  if (is.null(runs_for_line) || nrow(runs_for_line) == 0) return("")

  if (nrow(runs_for_line) == 1) {
    run <- runs_for_line[1, ]
    return(paste0('<pre id="runid-', run$runid, '" class="logtxt-pre"><code class="logtxt-code">', htmltools::htmlEscape(run$logtxt), '</code></pre>'))
  }

  random_id <- function() paste0(sample(c(letters, LETTERS), 12, replace = TRUE), collapse = "")

  tabset_id <- paste0("tabset_", random_id())
  tab_ids <- replicate(nrow(runs_for_line), paste0("tab_", random_id()))

  tab_pills <- paste0(
    '<ul id="', tabset_id, '" class="nav nav-tabs small-tab-ul" role="tablist">',
    paste(
      sapply(1:nrow(runs_for_line), function(i) {
        active_class <- if (i == 1) ' class="active"' else ''
        paste0('<li', active_class, '><a href="#', tab_ids[i], '" role="tab" data-toggle="tab">Run ', i, '</a></li>')
      }),
      collapse = "\n"
    ),
    '</ul>'
  )

  tab_content <- paste0(
    '<div class="tab-content">',
    paste(
      sapply(1:nrow(runs_for_line), function(i) {
        run <- runs_for_line[i, ]
        pane_class <- if (i == 1) "tab-pane active" else "tab-pane"
        paste0(
          '<div class="', pane_class, '" id="', tab_ids[i], '">',
            '<pre id="runid-', run$runid, '" class="logtxt-pre"><code class="logtxt-code">', htmltools::htmlEscape(run$logtxt), '</code></pre>',
          '</div>'
        )
      }),
      collapse="\n"
    ),
    '</div>'
  )
  paste0(tab_pills, tab_content)
}


#' @describeIn rr_map_report Generate HTML for the table display panel.
rr_make_tab_panel_html <- function(tab_main) {
  tab_pills <- paste0(
    '<ul id="tabtabs" class="nav nav-pills" role="tablist">',
    paste(
      sapply(1:nrow(tab_main), function(i) {
        row <- tab_main[i,]
        active_class <- if(i == 1) ' class="active"' else ''
        paste0('<li', active_class, '><a href="#tabtab', row$tabid, '" role="tab" data-toggle="tab">Tab ', row$tabid, '</a></li>')
      }),
      collapse = "\n"
    ),
    '</ul>'
  )

  tab_content <- paste0(
    '<div class="tab-content">',
    paste(
      sapply(1:nrow(tab_main), function(i) {
        row <- tab_main[i,]
        active_class <- if(i == 1) "tab-pane active" else "tab-pane"
        paste0(
          '<div class="', active_class, '" id="tabtab', row$tabid, '">',
            '<div class="art-tab-div">',
              '<h5>', htmltools::htmlEscape(row$tabtitle), '</h5>',
              row$tabhtml,
            '</div>',
          '</div>'
        )
      }),
      collapse="\n"
    ),
    '</div>'
  )
  paste0(tab_pills, tab_content)
}

#' @describeIn rr_map_report Generate HTML for the top control bar.
rr_make_controls_html <- function(all_map_types) {
  map_type_names <- names(all_map_types)
  if (length(map_type_names) == 0) return("")

  type_options <- paste0('<option value="', map_type_names, '">', map_type_names, '</option>', collapse = "\n")

  # The version selector is populated by JavaScript, so it's initially empty.
  paste0(
    '<div class="controls-div form-inline">',
      '<div class="form-group">',
        '<label for="map_type_selector">Map Type:</label>',
        '<select id="map_type_selector" class="form-control input-sm">', type_options, '</select>',
      '</div>',
      '<div class="form-group">',
        '<label for="version_selector">Map Version:</label>',
        '<select id="version_selector" class="form-control input-sm"></select>',
      '</div>',
    '</div>'
  )
}

#' @describeIn rr_map_report Copy package assets to the report directory.
rr_copy_pkg_assets <- function(output_dir) {
  pkg_www_dir <- system.file("www", package = "repboxReport")
  if (pkg_www_dir == "") {
    warning("Could not find 'inst/www' directory in repboxReport package. Report assets will be missing.")
    return()
  }

  shared_dir <- file.path(output_dir, "shared")
  if (!dir.exists(shared_dir)) dir.create(shared_dir, recursive = TRUE)

  files_to_copy <- list.files(pkg_www_dir, recursive = TRUE, full.names = TRUE)

  if (length(files_to_copy) > 0) {
    file.copy(files_to_copy, shared_dir, recursive = TRUE, overwrite = TRUE)
  } else {
     warning("No assets found in 'inst/www' to copy.")
  }
}
